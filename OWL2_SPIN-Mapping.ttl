@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix sparql: <http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .

@prefix sp: <http://spinrdf.org/sp#> .
# syntactically represent SPARQL queries and update commands as RDF triples

@prefix spin: <http://spinrdf.org/spin#> .
# attach constraints and rules to RDFS classes
# encapsulate reusable SPARQL queries into functions and templates

@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .

@prefix spif: <http://spinrdf.org/spif#> . 
# generally useful SPARQL functions defined using SPIN
# functions that are impossible or difficult to express in terms of other functions, but rather will require a native implementation in languages like Java

@prefix spl: <http://spinrdf.org/spl#> . 
# SPIN Standard Modules Library (SPL)
# generally useful SPARQL functions (expressed as SPIN functions), and SPIN templates
# top-level classification of functions, and definitions of the standard SPARQL functions
# functions that can be expressed entirely in terms of other SPARQL expressions and standard built-ins

# @prefix spinowl: <http://topbraid.org/spin/spinowl> .
# constraint checking axioms for a subset of OWL, using closed-world semantics

@prefix spinx: <http://spinrdf.org/spinx#> . 

@prefix owl2: <http://constraints.org/owl2#> .

@prefix functions:<http://www.example.org/functions#> .
@prefix templates:<http://www.example.org/templates#> .

@prefix sparql: <http://www.w3.org/TR/sparql11-query/#> .

@prefix a:        <http://www.example.org/OWL2InstanceData#> .

<constraints/owl> 
	a owl:Ontology ;
	rdfs:comment "Contains constraint checking axioms for a subset of OWL 2, using closed-world semantics." ;
	owl:imports <http://spinrdf.org/spl> ;
	owl:imports <http://www.w3.org/2005/xpath-functions> ;
#	owl:imports <http://topbraid.org/sparqlmotionfunctions> ;
#	owl:import <http://spinrdf.org/spif> ;
	owl:versionInfo "0.0.1" .

# ---------------
# class constraints: 
	
owl:Thing 
	spin:constraint 
		# set-oriented operations ( on data ranges )
		# -----
		# DataOneOf
		[   a owl2:DataOneOf_1 ] , [   a owl2:DataOneOf_2 ] , [   a owl2:DataOneOf_3 ] , [   a owl2:DataOneOf_4 ] , [   a owl2:DataOneOf_5 ] ,
	
		# set-oriented operations ( on class expressions )
		# -----
		# ObjectIntersectionOf ( 2 CE )
		[   a owl2:ObjectIntersectionOf_2CE ] ,
		# ObjectIntersectionOf ( 3 CE )
		[   a owl2:ObjectIntersectionOf_3CE ] ,
		# ObjectUnionOf ( 2 CE )
		[   a owl2:ObjectUnionOf_2CE ] ,
		# ObjectUnionOf ( 3 CE )
		[   a owl2:ObjectUnionOf_3CE ] ,
		# ObjectComplementOf
		[   a owl2:ObjectComplementOf ] ,
		# ObjectOneOf
		[   a owl2:ObjectOneOf_1 ] , [   a owl2:ObjectOneOf_2 ] , [   a owl2:ObjectOneOf_3 ] , [   a owl2:ObjectOneOf_4 ] , [   a owl2:ObjectOneOf_5 ] ,
		
		# object property restrictions
		# -----
		# ObjectSomeValuesFrom
		[   a owl2:ObjectSomeValuesFrom ] ,
		# ObjectAllValuesFrom
		[   a owl2:ObjectAllValuesFrom ] ,
		# ObjectHasValue
		[   a owl2:ObjectHasValue ] ,
		
		# object property cardinality restrictions
		# -----
		# ObjectMinCardinality
		[   a owl2:ObjectMinCardinality ] ,
		# ObjectMaxCardinality
		[   a owl2:ObjectMaxCardinality ] ,
		# ObjectExactCardinality
		[   a owl2:ObjectExactCardinality ] ,
		
		# data property restrictions
		# -----
		# DataSomeValuesFrom
		[   a owl2:DataSomeValuesFrom ] ,
		# DataAllValuesFrom
		[   a owl2:DataAllValuesFrom ] ,
		# DataHasValue
		[   a owl2:DataHasValue ] ,
		
		# data property cardinality restrictions
		# -----
		# owl2:DataMinCardinality
		[   a owl2:DataMinCardinality ] ,
		# owl2:DataMaxCardinality
		[   a owl2:DataMaxCardinality ] ,
		# owl2:DataExactCardinality
		[   a owl2:DataExactCardinality ] ,
		
		# object property axioms
		# -----
		# SubObjectPropertyOf
		[   a owl2:SubObjectPropertyOf ] ,
		# ObjectPropertyChain ( 2 OPE )
		[   a owl2:ObjectPropertyChain_2OPE ] ,
		# ObjectPropertyChain ( 3 OPE )
		[   a owl2:ObjectPropertyChain_3OPE ] ,
		# EquivalentObjectProperties
		# DisjointObjectProperties
		[   a owl2:DisjointObjectProperties ] ,
		# InverseObjectProperties
		[   a owl2:InverseObjectProperties ] ,
		# ObjectPropertyDomain
		[   a owl2:ObjectPropertyDomain ] ,
		# ObjectPropertyRange
		[   a owl2:ObjectPropertyRange ] ,
		# FunctionalObjectProperty
		[   a owl2:FunctionalObjectProperty ] ,
		# InverseFunctionalObjectProperty
		[   a owl2:InverseFunctionalObjectProperty ] ,
		
		# data property axioms
		# -----
		# DataPropertyDomain
		[   a owl2:DataPropertyDomain ] ,
		# DataPropertyRange
		[   a owl2:DataPropertyRange ] ,
		
		# datatype definitions
		[   a owl2:DatatypeDefinition_Pattern ] ,
		
		
		# Disjoint Classes
		[   a owl2:DisjointClasses ] .
		# Disjoint Union of Class Expressions
#		[   a owl2:DisjointUnion_2DisjointClassExpressions_1 ] .
#		[   a owl2:DisjointUnion_2DisjointClassExpressions_2 ] ,
#		[   a owl2:DisjointUnion_2DisjointClassExpressions_3 ] .
		
rdfs:Literal 
	spin:constraint 
		# set-oriented operations
		# -----
		# DataComplementOf
		[   a owl2:DataComplementOf ] .

# -----

# ---------------
# ObjectIntersectionOf (  intersection of class expressions  )


# description
# -----
# An intersection class expression ObjectIntersectionOf( CE1 ... CEn ) contains all individuals that are instances of all class expressions CEi for 1 ≤ i ≤ n. 

# definition: 
# -----	
# ObjectIntersectionOf := 'ObjectIntersectionOf' '(' ClassExpression ClassExpression { ClassExpression } ')' 	

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:intersectionOf ( ?CE1 ?CE2 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:intersectionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#		FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectIntersectionOf_2CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectIntersectionOf";
	rdfs:label "ObjectIntersectionOf";
	rdfs:comment "ObjectIntersectionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:intersectionOf ( ?CE1 ?CE2 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:intersectionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:intersectionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . }
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE1" ] ]
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE2" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectIntersectionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " )" ] ] ) ].
					
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:intersectionOf ( ?CE1 ?CE2 ?CE3 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:intersectionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    ?rest_2 rdf:first ?CE3 .
#	    ?rest_2 rdf:rest ?rest_3 .
#	    FILTER ( ?rest_3 = rdf:nil ) .
#
#		FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . ?this rdf:type ?CE3 . }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectIntersectionOf_3CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectIntersectionOf";
	rdfs:label "ObjectIntersectionOf";
	rdfs:comment "ObjectIntersectionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:intersectionOf ( ?CE1 ?CE2 ?CE3 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:intersectionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	?rest_2 rdf:first ?CE3 .
#	    	?rest_2 rdf:rest ?rest_3 .
#	    	FILTER ( ?rest_3 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:intersectionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE3" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_3" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_3" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . ?this rdf:type ?CE2 . }
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE1" ] ]
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE2" ] ] 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE3" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectIntersectionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE3" ] ;
					sp:arg7 " )" ] ] ) ].

# -----

# ---------------
# ObjectUnionOf (  union of class expressions  )


# description
# -----
# A union class expression ObjectUnionOf( CE1 ... CEn ) contains all individuals that are instances of at least one class expression CEi for 1 ≤ i ≤ n. 

# definition: 
# -----	
# ObjectUnionOf := 'ObjectUnionOf' '(' ClassExpression ClassExpression { ClassExpression } ')' 

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:unionOf ( ?CE1 ?CE2 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:unionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#		FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectUnionOf_2CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectUnionOf";
	rdfs:label "ObjectUnionOf";
	rdfs:comment "ObjectUnionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:unionOf ( ?CE1 ?CE2 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:unionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:unionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } }
			[   a sp:Filter ;
                sp:expression [
					a sp:notExists ;
                    sp:elements ( 
						[   a sp:Union ;
							sp:elements ( 
							( 
								[   sp:object [ sp:varName "CE1" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) 
							(
								[   sp:object [ sp:varName "CE2" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) ) ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectUnionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " )" ] ] ) ].
					
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:unionOf ( ?CE1 ?CE2 ?CE3 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:unionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    ?rest_2 rdf:first ?CE3 .
#	    ?rest_2 rdf:rest ?rest_3 .
#	    FILTER ( ?rest_3 = rdf:nil ) .
#
#		FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } UNION { ?this rdf:type ?CE3 . } }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectUnionOf_3CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectUnionOf";
	rdfs:label "ObjectUnionOf";
	rdfs:comment "ObjectUnionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:unionOf ( ?CE1 ?CE2 ?CE3 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:unionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	?rest_2 rdf:first ?CE3 .
#	    	?rest_2 rdf:rest ?rest_3 .
#	    	FILTER ( ?rest_3 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:unionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE3" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_3" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_3" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } UNION { ?this rdf:type ?CE3 . } }
			[   a sp:Filter ;
                sp:expression [
					a sp:notExists ;
                    sp:elements ( 
						[   a sp:Union ;
							sp:elements ( 
							( 
								[   sp:object [ sp:varName "CE1" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) 
							(
								[   sp:object [ sp:varName "CE2" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] )
							(
								[   sp:object [ sp:varName "CE3" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) ) ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectUnionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE3" ] ;
					sp:arg7 " )" ] ] ) ].

# -----

# ---------------
# ObjectComplementOf ( complement of class expressions  )


# description
# -----
# A complement class expression ObjectComplementOf( CE ) contains all individuals that are not instances of the class expression CE. 

# definition: 
# -----	
# ObjectComplementOf := 'ObjectComplementOf' '(' ClassExpression ')'		

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
#
#	    ObjectComplementOf ( CE )
#	    -----				
#       ?class rdf:type owl:Class .
#       ?class owl:complementOf ?CE .
#
#       FILTER EXISTS { ?this rdf:type ?CE . } 
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectComplementOf
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectComplementOf";
	rdfs:label "ObjectComplementOf";
	rdfs:comment "ObjectComplementOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 

#	    	ObjectComplementOf ( CE )
#	    	-----				
#           ?class rdf:type owl:Class .
#           ?class owl:complementOf ?CE .
			
            [   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Class ]
            [   sp:subject [ sp:varName "class" ];
				sp:predicate owl:complementOf;
				sp:object [ sp:varName "CE" ] ]				
				
#           FILTER EXISTS { ?this rdf:type ?CE . }  
#           -----			
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectComplementOf ( " ;
					sp:arg2 [ sp:varName "CE" ] ;
					sp:arg3 " )" ] ] ) ].

# -----	

# ---------------
# ObjectOneOf ( enumeration of individuals )


# description
# -----
# An enumeration of individuals ObjectOneOf( a1 ... an ) contains exactly the individuals ai with 1 ≤ i ≤ n. 

# definition
# -----	
# ObjectOneOf := 'ObjectOneOf' '(' Individual { Individual }')' 

# SPIN templates:
# -----

# 1 Individual
owl2:ObjectOneOf_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R1" ];
					sp:arg2 rdf:nil ] ]
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           FILTER ( ?isElementInList_I1 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " )" ] ] ) ].

# 2 Individuals
owl2:ObjectOneOf_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R2" ];
					sp:arg2 rdf:nil ] ]
#			BIND( ( IF( BOUND( ?I2_tmp ), ?I2_tmp, ""^^xsd:string ) ) AS ?I2 ) .
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]
#           BIND( ( IF( BOUND( ?I2_tmp ) && ?I2_tmp = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           FILTER ( ?isElementInList_I1 = "false"^^xsd:boolean && ?isElementInList_I2 = "false"^^xsd:boolean  ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ;
					sp:arg2 [
						a sp:eq ;
						sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " )" ] ] ) ].

# 3 Individuals
owl2:ObjectOneOf_3
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I3_tmp" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R3" ];
					sp:arg2 rdf:nil ] ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I3_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I3_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I3" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I3"^^xsd:boolean ] ]
				
#           FILTER ( 
#				?isElementInList_I1 = "false"^^xsd:boolean && 
#				?isElementInList_I2 = "false"^^xsd:boolean && 
#				?isElementInList_I3 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:and ;
                    sp:arg1 [ 
						a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [ 
					    a sp:eq ;
                        sp:arg1 [ sp:varName "isElementInList_I3"^^xsd:boolean ] ;
                        sp:arg2 "false"^^xsd:boolean ]
				] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 " | I3: " ;
#					sp:arg10 [ sp:varName "I3" ] ;
#					sp:arg11 " | isElementInList_I3: " ;
#					sp:arg12 [ sp:varName "isElementInList_I3" ] ;
#					sp:arg13 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "I3" ] ;
					sp:arg7 " )" ] ] ) ].
					
# 4 Individuals
owl2:ObjectOneOf_4
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I3_tmp" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I3_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I3_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I3" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I3"^^xsd:boolean ] ]
				
#           4. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I4_tmp" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R4" ];
					sp:arg2 rdf:nil ] ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I4_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I4_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I4" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I4"^^xsd:boolean ] ]
				
#           FILTER ( 
#				?isElementInList_I1 = "false"^^xsd:boolean && 
#				?isElementInList_I2 = "false"^^xsd:boolean && 
#				?isElementInList_I3 = "false"^^xsd:boolean && 
#				?isElementInList_I4 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:and ;
                    sp:arg1 [ 
						a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I4"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
				] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 " | I3: " ;
#					sp:arg10 [ sp:varName "I3" ] ;
#					sp:arg11 " | isElementInList_I3: " ;
#					sp:arg12 [ sp:varName "isElementInList_I3" ] ;
#					sp:arg13 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "I3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "I4" ] ;
					sp:arg9 " )" ] ] ) ].
					
					# 4 Individuals
owl2:ObjectOneOf_5
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I3_tmp" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I3_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I3_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I3" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I3"^^xsd:boolean ] ]
				
#           4. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I4_tmp" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I4_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I4_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I4" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I4"^^xsd:boolean ] ]
				
#           5. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R4" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I5_tmp" ] ]
			[   sp:subject [ sp:varName "R4" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R5" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R5" ];
					sp:arg2 rdf:nil ] ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I5_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I5_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I5" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I5_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I5_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I5"^^xsd:boolean ] ]
				
#           FILTER ( 
#				?isElementInList_I1 = "false"^^xsd:boolean && 
#				?isElementInList_I2 = "false"^^xsd:boolean && 
#				?isElementInList_I3 = "false"^^xsd:boolean && 
#				?isElementInList_I4 = "false"^^xsd:boolean && 
#				?isElementInList_I5 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:and ;
                    sp:arg1 [ 
						a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:and ;
							sp:arg1 [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isElementInList_I4"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ;
							sp:arg2 [
								a sp:eq ;
								sp:arg1 [ sp:varName "isElementInList_I5"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ] ;
					] ;
				] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 " | I3: " ;
#					sp:arg10 [ sp:varName "I3" ] ;
#					sp:arg11 " | isElementInList_I3: " ;
#					sp:arg12 [ sp:varName "isElementInList_I3" ] ;
#					sp:arg13 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "I3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "I4" ] ;
					sp:arg9 " " ;
					sp:arg10 [ sp:varName "I5" ] ;
					sp:arg11 " )" ] ] ) ].

# -----

# ---------------
# DataComplementOf ( complement of data ranges  )


# description
# -----
# A complement data range DataComplementOf( DR ) contains all tuples of literals that are not contained in the data range DR. 

# definition: 
# -----	
# ObjectComplementOf := 'ObjectComplementOf' '(' ClassExpression ')'		

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
#
#	    DataComplementOf ( DR )
#	    -----				
#       ?class rdf:type rdfs:Datatype .
#       ?class owl:complementOf ?DR .
#
#       FILTER EXISTS { ?this rdf:type ?DR . } 
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:DataComplementOf
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataComplementOf";
	rdfs:label "DataComplementOf";
	rdfs:comment "DataComplementOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 

#	    	ObjectComplementOf ( DR )
#	    	-----				
#           ?class rdf:type rdfs:Datatype .
#           ?class owl:complementOf ?DR .
			
            [   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object rdfs:Datatype ]
            [   sp:subject [ sp:varName "class" ];
				sp:predicate owl:complementOf;
				sp:object [ sp:varName "DR" ] ]				
				
#           FILTER EXISTS { ?this rdf:type ?DR . }  
#           -----			
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "DR" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataComplementOf ( " ;
					sp:arg2 [ sp:varName "DR" ] ;
					sp:arg3 " )" ] ] ) ].

# -----	

# ---------------
# DataOneOf ( enumeration of literals )


# description
# -----
# An enumeration of literals DataOneOf( lt1 ... ltn ) contains exactly the explicitly specified literals lti with 1 ≤ i ≤ n. The resulting data range has arity one. 

# definition
# -----	
# DataOneOf := 'DataOneOf' '(' Literal { Literal } ')' 

# SPIN templates:
# -----

# 1 literal
owl2:DataOneOf_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?literal ) . 
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "literal" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R1" ];
					sp:arg2 rdf:nil ] ]
#           BIND( ( IF( ?L1 = ?L, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1" ] ;
						sp:arg2 [ sp:varName "literal" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           FILTER ( ?isLInDT_L1 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " )" ] ] ) ] .

# 2 literals
owl2:DataOneOf_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R2" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           FILTER ( ?isLInDT_L1 = "false"^^xsd:boolean && ?isLInDT_L2 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ;
					sp:arg2 [
						a sp:eq ;
						sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " )" ] ] ) ].

# 3 literals
owl2:DataOneOf_3
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L3" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R3" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L3 ) ) AS ?L3_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L3_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L3" ] ] ] 
#           BIND( ( IF( ?L3_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L3 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L3_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L3"^^xsd:boolean ] ] 
				
#           FILTER ( 
#           	?isLInDT_L1 = "false"^^xsd:boolean && 
#           	?isLInDT_L2 = "false"^^xsd:boolean && 
#               ?isLInDT_L3 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [
						a sp:eq ;
						sp:arg1 [ sp:varName "isLInDT_L3"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 " | L3: " ;
#					sp:arg16 [ sp:varName "L3" ] ;
#					sp:arg17 " | isLInDT_L3: " ;
#					sp:arg18 [ sp:varName "isLInDT_L3" ] ;
#					sp:arg19 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "L3" ] ;
					sp:arg7 " )" ] ] ) ].

# 4 literals
owl2:DataOneOf_4
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L3" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
#           BIND ( ( str ( ?L3 ) ) AS ?L3_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L3_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L3" ] ] ] 
#           BIND( ( IF( ?L3_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L3 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L3_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L3"^^xsd:boolean ] ] 
				
#           4. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L4" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R4" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L4 ) ) AS ?L4_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L4_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L4" ] ] ] 
#           BIND( ( IF( ?L4_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L4 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L4_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L4"^^xsd:boolean ] ] 
				
#           FILTER ( 
#           	?isLInDT_L1 = "false"^^xsd:boolean && 
#           	?isLInDT_L2 = "false"^^xsd:boolean && 
#           	?isLInDT_L3 = "false"^^xsd:boolean && 
#               ?isLInDT_L4 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L4"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
						] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 " | L3: " ;
#					sp:arg16 [ sp:varName "L3" ] ;
#					sp:arg17 " | isLInDT_L3: " ;
#					sp:arg18 [ sp:varName "isLInDT_L3" ] ;
#					sp:arg19 " | L4: " ;
#					sp:arg20 [ sp:varName "L4" ] ;
#					sp:arg21 " | isLInDT_L4: " ;
#					sp:arg22 [ sp:varName "isLInDT_L4" ] ;
#					sp:arg23 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "L3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "L4" ] ;
					sp:arg9 " )" ] ] ) ].

# 5 literals
owl2:DataOneOf_5
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L3" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
#           BIND ( ( str ( ?L3 ) ) AS ?L3_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L3_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L3" ] ] ] 
#           BIND( ( IF( ?L3_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L3 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L3_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L3"^^xsd:boolean ] ] 
				
#           4. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L4" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
#           BIND ( ( str ( ?L4 ) ) AS ?L4_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L4_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L4" ] ] ] 
#           BIND( ( IF( ?L4_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L4 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L4_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L4"^^xsd:boolean ] ] 
				
#           5. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R4" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L5" ] ]
			[   sp:subject [ sp:varName "R4" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R5" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R5" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L5 ) ) AS ?L5_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L5_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L5" ] ] ] 
#           BIND( ( IF( ?L5_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L5 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L5_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L5"^^xsd:boolean ] ] 
				
#           FILTER ( 
#           	?isLInDT_L1 = "false"^^xsd:boolean && 
#           	?isLInDT_L2 = "false"^^xsd:boolean && 
#           	?isLInDT_L3 = "false"^^xsd:boolean && 
#           	?isLInDT_L4 = "false"^^xsd:boolean && 
#               ?isLInDT_L5 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:and ;
						sp:arg1 [ 
							a sp:and ;
							sp:arg1 [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ;
							sp:arg2 [
								a sp:eq ;
								sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L4"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L5"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
						] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 " | L3: " ;
#					sp:arg16 [ sp:varName "L3" ] ;
#					sp:arg17 " | isLInDT_L3: " ;
#					sp:arg18 [ sp:varName "isLInDT_L3" ] ;
#					sp:arg19 " | L4: " ;
#					sp:arg20 [ sp:varName "L4" ] ;
#					sp:arg21 " | isLInDT_L4: " ;
#					sp:arg22 [ sp:varName "isLInDT_L4" ] ;
#					sp:arg23 " | L5: " ;
#					sp:arg24 [ sp:varName "L5" ] ;
#					sp:arg25 " | isLInDT_L5: " ;
#					sp:arg26 [ sp:varName "isLInDT_L5" ] ;
#					sp:arg27 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "L3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "L4" ] ;
					sp:arg9 " " ;
					sp:arg10 [ sp:varName "L5" ] ;
					sp:arg11 " )" ] ] ) ].

# -----

# ---------------
# ObjectMinCardinality ( Object Property Cardinality Restriction )


# description
# -----
# A minimum cardinality expression ObjectMinCardinality( n OPE CE ) consists of a nonnegative integer n, 
# an object property expression OPE, and a class expression CE, and it contains all those individuals 
# that are connected by OPE to at least n different individuals that are instances of CE. 
# If CE is missing, it is taken to be owl:Thing.

# definition: 
# -----	
# ObjectMinCardinality := 'ObjectMinCardinality' '(' nonNegativeInteger ObjectPropertyExpression [ ClassExpression ] ')'			

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    ObjectMinCardinality ( Minimum OPE CE )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#		?class owl:onProperty ?OPE .
#       OPTIONAL { ?class owl:onClass ?CE_tmp } .
#		BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
#
#	    qualifiedCardinality < Minimum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality < ?Minimum ) .
#
#       OPE is object property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectMinCardinality
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectMinCardinality";
	rdfs:label "ObjectMinCardinality";
	rdfs:comment "ObjectMinCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	ObjectMinCardinality ( Minimum OPE CE )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#			?class owl:onProperty ?OPE .
#           OPTIONAL { ?class owl:onClass ?CE_tmp } .
#			BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minCardinality;
				        sp:object [ sp:varName "Minimum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minQualifiedCardinality;
				        sp:object [ sp:varName "Minimum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "OPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "CE_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "CE_tmp" ] ] ;
                        sp:arg2 [ sp:varName "CE_tmp" ] ;
                        sp:arg3 owl:Thing ] ;
                    sp:variable [ sp:varName "CE" ] ]
				
#	    	qualifiedCardinality < Minimum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#			FILTER ( qualifiedCardinality < ?Minimum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityObjectProperties;
					sp:arg1 [ sp:varName "OPE" ] ;
					sp:arg2 [ sp:varName "CE" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Minimum" ] ] ]
					
#           OPE is object property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectMinCardinality ( " ;
					sp:arg2 [ sp:varName "Minimum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE" ] ;
					sp:arg7 " )" ] ] ) ].

# -----	

# ---------------
# ObjectMaxCardinality


# description
# -----
# A maximum cardinality expression ObjectMaxCardinality( n OPE CE ) consists of a nonnegative integer n, an object property expression OPE, 
# and a class expression CE, and it contains all those individuals that are connected by OPE to at most n different individuals 
# that are instances of CE. If CE is missing, it is taken to be owl:Thing.

# definition
# -----
# ObjectMaxCardinality := 'ObjectMaxCardinality' '(' nonNegativeInteger ObjectPropertyExpression [ ClassExpression ] ')'

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    ObjectMaxCardinality ( Maximum OPE CE )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#		?class owl:onProperty ?OPE .
#       OPTIONAL { ?class owl:onClass ?CE_tmp } .
#		BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
#
#	    qualifiedCardinality > Maximum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality > ?Maximum ) .
#
#       OPE is object property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectMaxCardinality
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectMaxCardinality";
	rdfs:label "ObjectMaxCardinality";
	rdfs:comment "ObjectMaxCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	ObjectMaxCardinality ( Maximum OPE CE )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#			?class owl:onProperty ?OPE .
#           OPTIONAL { ?class owl:onClass ?CE_tmp } .
#			BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxCardinality;
				        sp:object [ sp:varName "Maximum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxQualifiedCardinality;
				        sp:object [ sp:varName "Maximum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "OPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "CE_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "CE_tmp" ] ] ;
                        sp:arg2 [ sp:varName "CE_tmp" ] ;
                        sp:arg3 owl:Thing ] ;
                    sp:variable [ sp:varName "CE" ] ]
				
#	    	qualifiedCardinality > Maximum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#			FILTER ( qualifiedCardinality > ?Maximum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityObjectProperties;
					sp:arg1 [ sp:varName "OPE" ] ;
					sp:arg2 [ sp:varName "CE" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Maximum" ] ] ]
					
#           OPE is object property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectMaxCardinality ( " ;
					sp:arg2 [ sp:varName "Maximum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE" ] ;
					sp:arg7 " )" ] ] ) ].
					
# -----
		
# ---------------
# ObjectExactCardinality (object property cardinality restriction )
		

# description
# -----
# An exact cardinality expression ObjectExactCardinality( n OPE CE ) consists of a nonnegative integer n, an object property expression OPE, 
# and a class expression CE, and it contains all those individuals that are connected by OPE to exactly n different individuals 
# that are instances of CE. If CE is missing, it is taken to be owl:Thing. 
		
# definition 
# -----
# ObjectExactCardinality := 'ObjectExactCardinality' '(' nonNegativeInteger ObjectPropertyExpression [ ClassExpression ] ')' 
	
# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    ObjectExactCardinality ( Exact OPE CE )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#		?class owl:onProperty ?OPE .
#       OPTIONAL { ?class owl:onClass ?CE_tmp } .
#		BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
#
#	    qualifiedCardinality != Exact
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality != ?Exact ) .
#
#       OPE is object property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:ObjectExactCardinality
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectExactCardinality";
	rdfs:label "ObjectExactCardinality";
	rdfs:comment "ObjectExactCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	ObjectMinCardinality ( Exact OPE CE )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#			?class owl:onProperty ?OPE .
#           OPTIONAL { ?class owl:onClass ?CE_tmp } .
#			BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:cardinality;
				        sp:object [ sp:varName "Exact" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:qualifiedCardinality;
				        sp:object [ sp:varName "Exact" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "OPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "CE_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "CE_tmp" ] ] ;
                        sp:arg2 [ sp:varName "CE_tmp" ] ;
                        sp:arg3 owl:Thing ] ;
                    sp:variable [ sp:varName "CE" ] ]
				
#	    	qualifiedCardinality != Exact
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#			FILTER ( qualifiedCardinality != ?Exact ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityObjectProperties;
					sp:arg1 [ sp:varName "OPE" ] ;
					sp:arg2 [ sp:varName "CE" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Exact" ] ] ]
					
#           OPE is object property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectExactCardinality ( " ;
					sp:arg2 [ sp:varName "Exact" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE" ] ;
					sp:arg7 " )" ] ] ) ].
	
# -----

# ---------------
# DataMinCardinality


# description
# -----
# A minimum cardinality expression DataMinCardinality( n DPE DR ) consists of a nonnegative integer n, a data property expression DPE, 
# and a unary data range DR, and it contains all those individuals that are connected by DPE to at least n different literals in DR. 
# If DR is not present, it is taken to be rdfs:Literal. 

# definition
# -----
# DataMinCardinality := 'DataMinCardinality' '(' nonNegativeInteger DataPropertyExpression [ DataRange ] ')' 

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    DataMinCardinality ( Minimum DPE DR )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#		?class owl:onProperty ?DPE .
#       OPTIONAL { ?class owl:onClass ?DR_tmp } .
#	    BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) 
#
#	    qualifiedCardinality < Minimum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality < ?Minimum ) .
#
#       DPE is data property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:DataMinCardinality
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataMinCardinality";
	rdfs:label "DataMinCardinality";
	rdfs:comment "DataMinCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	DataMinCardinality ( Minimum DPE DR )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#			?class owl:onProperty ?DPE .
#           OPTIONAL { ?class owl:onClass ?DR_tmp } .
#			BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minCardinality;
				        sp:object [ sp:varName "Minimum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minQualifiedCardinality;
				        sp:object [ sp:varName "Minimum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "DPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "DR_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "DR_tmp" ] ] ;
                        sp:arg2 [ sp:varName "DR_tmp" ] ;
                        sp:arg3 rdfs:Literal ] ;
                    sp:variable [ sp:varName "DR" ] ]	
				
#	    	qualifiedCardinality < Minimum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( DPE, DR ) ) AS ?qualifiedCardinality ) . 
#			FILTER ( qualifiedCardinality < ?Minimum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityDataProperties;
					sp:arg1 [ sp:varName "DPE" ] ;
					sp:arg2 [ sp:varName "DR" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Minimum" ] ] ]
					
#           DPE is data property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
							
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataMinCardinality ( " ;
					sp:arg2 [ sp:varName "Minimum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "DR" ] ;
					sp:arg7 " )" ] ] ) ].

# -----	

# ---------------
# DataMaxCardinality



# description
# -----
# A maximum cardinality expression DataMaxCardinality( n DPE DR ) consists of a nonnegative integer n, a data property expression DPE, 
# and a unary data range DR, and it contains all those individuals that are connected by DPE to at most n different literals in DR. 
# If DR is not present, it is taken to be rdfs:Literal. 

# definition
# -----
# DataMaxCardinality := 'DataMaxCardinality' '(' nonNegativeInteger DataPropertyExpression [ DataRange ] ')' 

# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    DataMaxCardinality ( Maximum DPE DR )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#		?class owl:onProperty ?DPE .
#       OPTIONAL { ?class owl:onClass ?DR_tmp } .
#	    BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) 
#
#	    qualifiedCardinality > Maximum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality > ?Maximum ) .
#
#       DPE is data property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:DataMaxCardinality
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataMaxCardinality";
	rdfs:label "DataMaxCardinality";
	rdfs:comment "DataMaxCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	DataMinCardinality ( Maximum DPE DR )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#			?class owl:onProperty ?DPE .
#           OPTIONAL { ?class owl:onClass ?DR_tmp } .
#			BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxCardinality;
				        sp:object [ sp:varName "Maximum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxQualifiedCardinality;
				        sp:object [ sp:varName "Maximum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "DPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "DR_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "DR_tmp" ] ] ;
                        sp:arg2 [ sp:varName "DR_tmp" ] ;
                        sp:arg3 rdfs:Literal ] ;
                    sp:variable [ sp:varName "DR" ] ]	
				
#	    	qualifiedCardinality > Maximum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( DPE, DR ) ) AS ?qualifiedCardinality ) . 
#			FILTER ( qualifiedCardinality > ?Maximum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityDataProperties;
					sp:arg1 [ sp:varName "DPE" ] ;
					sp:arg2 [ sp:varName "DR" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Maximum" ] ] ]
					
#           DPE is data property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
							
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataMaxCardinality ( " ;
					sp:arg2 [ sp:varName "Maximum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "DR" ] ;
					sp:arg7 " )" ] ] ) ].

# -----	

# ---------------
# DataExactCardinality


# description
# -----
# An exact cardinality expression DataExactCardinality( n DPE DR ) consists of a nonnegative integer n, a data property expression DPE, 
# and a unary data range DR, and it contains all those individuals that are connected by DPE to exactly n different literals in DR. 
# If DR is not present, it is taken to be rdfs:Literal. 

# definition 
# -----
# DataExactCardinality := 'DataExactCardinality' '(' nonNegativeInteger DataPropertyExpression [ DataRange ] ')' 
	
# SPIN template:
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    DataExactCardinality ( Exact DPE DR )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#		?class owl:onProperty ?DPE .
#       OPTIONAL { ?class owl:onClass ?DR_tmp } .
#	    BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) 
#
#	    qualifiedCardinality != Exact
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality > ?Exact ) .
#
#       DPE is data property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2:DataExactCardinality
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataExactCardinality";
	rdfs:label "DataExactCardinality";
	rdfs:comment "DataExactCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	DataExactCardinality ( Exact DPE DR )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#			?class owl:onProperty ?DPE .
#           OPTIONAL { ?class owl:onClass ?DR_tmp } .
#			BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:cardinality;
				        sp:object [ sp:varName "Exact" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:qualifiedCardinality;
				        sp:object [ sp:varName "Exact" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "DPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "DR_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "DR_tmp" ] ] ;
                        sp:arg2 [ sp:varName "DR_tmp" ] ;
                        sp:arg3 rdfs:Literal ] ;
                    sp:variable [ sp:varName "DR" ] ]	
				
#	    	qualifiedCardinality != Exact
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( DPE, DR ) ) AS ?qualifiedCardinality ) . 
#			FILTER ( qualifiedCardinality != ?Exact ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityDataProperties;
					sp:arg1 [ sp:varName "DPE" ] ;
					sp:arg2 [ sp:varName "DR" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Exact" ] ] ]
					
#           DPE is data property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
							
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataExactCardinality ( " ;
					sp:arg2 [ sp:varName "Exact" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "DR" ] ;
					sp:arg7 " )" ] ] ) ].	
	
# -----			

# ---------------
# ObjectSomeValuesFrom ( object property restrictions - existential quantification )


# description
# -----
# An existential class expression ObjectSomeValuesFrom( OPE CE ) consists of an object property expression OPE 
# and a class expression CE, and it contains all those individuals that are connected by OPE to an individual that is an instance of CE. 

# definition
# -----
# ObjectSomeValuesFrom := 'ObjectSomeValuesFrom' '(' ObjectPropertyExpression ClassExpression ')' 

# SPIN template:
# -----
owl2:ObjectSomeValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectSomeValuesFrom" ;
	rdfs:label "ObjectSomeValuesFrom" ;
	rdfs:comment "ObjectSomeValuesFrom" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where (  
#       WHERE {
#    		?this rdf:type ?subC . 
#    		?subC rdfs:subClassOf* ?C .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#    		?C owl:someValuesFrom ?CE .
#		    ?C owl:onProperty ?OPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:someValuesFrom ;
				sp:object [ sp:varName "CE" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "OPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
				
#    		FILTER ( sp:not ( spl:hasValueOfType ( ?this, ?OPE, ?CE ) ) ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValueOfType ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "OPE" ] ;
						sp:arg3 [ sp:varName "CE" ] ] ] ]
						
#           OPE is object property expression	
#           -----
#           FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectSomeValuesFrom ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ].
					
# -----

# ---------------
# ObjectAllValuesFrom ( object property restriction - universal quantification )


# description
# -----
# A universal class expression ObjectAllValuesFrom( OPE CE ) consists of an object property expression OPE and a class expression CE, 
# and it contains all those individuals that are connected by OPE only to individuals that are instances of CE. 

# definition
# -----
# ObjectAllValuesFrom := 'ObjectAllValuesFrom' '(' ObjectPropertyExpression ClassExpression ')' 	

# SPIN template:
# -----
# CONSTRUCT {
#   _:violation 
#     a spin:ConstraintViolation ;
#     rdfs:label ?label
#     spin:violationRoot ?violationRoot ;
#     spin:violationPath ?violationPath }
# WHERE {
#    ?C owl:allValuesFrom ?CE .
#    ?C owl:onProperty ?OPE . 
#    ?C a owl:Restriction .
#    -----
#
#    ?this a ?subC . 
#    ?subC rdfs:subClassOf* ?C .
#    -----
#
#	 ?this ?subOPE ?object .	
#	 ?subOPE rdfs:subPropertyOf* ?OPE .
#    -----
#
#    FILTER ( sp:not ( spl:instanceOf ( ?object, ?CE ) ) ) . 
#
#    OPE is object property expression	
#    -----
#    FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
#
#	 BIND ( ( ... ) AS ?label ) . }
owl2:ObjectAllValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectAllValuesFrom" ;
	rdfs:label "ObjectAllValuesFrom" ;
	rdfs:comment "ObjectAllValuesFrom" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object "" ] );
		sp:where (  				
#    		?C owl:allValuesFrom ?CE .
#		    ?C owl:onProperty ?OPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:allValuesFrom ;
				sp:object [ sp:varName "CE" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "OPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
	
#    		?this rdf:type ?subC . 
#    		?subC rdfs:subClassOf* ?C .
#           -----

			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
	
#		    ?this ?subOPE ?object .	
#		    ?subOPE rdfs:subPropertyOf* ?OPE .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subOPE" ] ;
				sp:object [ sp:varName "object" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subOPE" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subPropertyOf ] ;
			    sp:object [ sp:varName "OPE" ] ]
				
#    		FILTER ( sp:not ( spl:instanceOf ( ?object, ?CE ) ) ) . 
#			[   a sp:Filter ;
#				sp:expression [ 
#					a sp:not ;
#				    sp:arg1 [ 
#						a spl:instanceOf ;
#				        sp:arg1 [ sp:varName "object" ] ;
#						sp:arg2 [ sp:varName "CE" ] ] ] ]

#           FILTER NOT EXISTS { ?object rdf:type ?CE . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE" ] ] ) ] ]
				
#           OPE is object property expression	
#           -----
#           FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
				
#    		BIND ( ... ) AS ?label ) .
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectAllValuesFrom ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ].
	
# -----	

# ---------------
# ObjectHasValue ( object property restrictions - individual value restriction )


# description
# -----
# A has-value class expression ObjectHasValue( OPE a ) consists of an object property expression OPE and an individual a, 
# and it contains all those individuals that are connected by OPE to a. 

# definition
# -----
# ObjectHasValue := 'ObjectHasValue' '(' ObjectPropertyExpression Individual ')' 

# SPIN template:
# -----
owl2:ObjectHasValue
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectHasValue" ;
	rdfs:label "ObjectHasValue" ;
	rdfs:comment "ObjectHasValue" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object [ sp:varName "property" ] ] );
		sp:where (  
#       WHERE {
#		    ?this rdf:type ?subC . 
#		    ?subC rdfs:subClassOf* ?C . 
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#	        ?C rdf:type owl:Restriction ;
#   	    ?C owl:onProperty ?OPE ;
#       	?C owl:hasValue ?I . 
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "OPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:hasValue ;
				sp:object [ sp:varName "I" ] ]
			
#           FILTER ( sp:not ( spl:hasValue ( ?this, ?OPE, ?I ) ) ) .
#           -----			
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValue ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "OPE" ] ;
						sp:arg3 [ sp:varName "I" ] ] ] ]

#           OPE is object property expression	
#           -----
#           FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectHasValue ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I" ] ;
					sp:arg5 " )" ] ] ) ].
					
# -----

# ---------------
# DataSomeValuesFrom


# description
# -----
# An existential class expression DataSomeValuesFrom( DPE1 ... DPEn DR ) consists of n data property expressions DPEi, 1 ≤ i ≤ n, 
# and a data range DR whose arity MUST be n. Such a class expression contains all those individuals that are connected by DPEi to literals lti, 1 ≤ i ≤ n, 
# such that the tuple ( lt1 , ..., ltn ) is in DR. 

# definition
# -----
# DataSomeValuesFrom := 'DataSomeValuesFrom' '(' DataPropertyExpression { DataPropertyExpression } DataRange ')

# SPIN template:
# -----
owl2:DataSomeValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataSomeValuesFrom" ;
	rdfs:label "DataSomeValuesFrom" ;
	rdfs:comment "DataSomeValuesFrom" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object "" ] );
		sp:where (  
#	 		for all classes in the class hierarchy of ?this
#    		-----
#    		?this a ?type . 
#    		?type sp:path ?C . 

			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#    		?C owl:someValuesFrom ?DR .
#		    ?C owl:onProperty ?DPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:someValuesFrom ;
				sp:object [ sp:varName "DR" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
				
#    		FILTER ( sp:not ( spl:hasValueOfType ( ?this, ?DPE, ?DR ) ) ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValueOfType ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "DPE" ] ;
						sp:arg3 [ sp:varName "DR" ] ] ] ]
						
#           DPE is data property expression	
#           -----
#           FILTER NOT EXISTS { ?this ?DPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataSomeValuesFrom ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# DataAllValuesFrom ( data property restriction - universal quantification )


# description
# -----
# A universal class expression DataAllValuesFrom( DPE1 ... DPEn DR ) consists of n data property expressions DPEi, 1 ≤ i ≤ n, and a data range DR whose arity MUST be n. 
# Such a class expression contains all those individuals that are connected by DPEi only to literals lti, 1 ≤ i ≤ n, such that each tuple ( lt1 , ..., ltn ) is in DR. 

# definition
# -----
# DataAllValuesFrom := 'DataAllValuesFrom' '(' DataPropertyExpression { DataPropertyExpression } DataRange ')' 

# SPIN template:
# -----
owl2:DataAllValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataAllValuesFrom" ;
	rdfs:label "DataAllValuesFrom" ;
	rdfs:comment "DataAllValuesFrom" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object "" ] );
		sp:where (  	
#		WHERE {
		
#    		?C owl:allValuesFrom ?DR .
#		    ?C owl:onProperty ?DPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:allValuesFrom ;
				sp:object [ sp:varName "DR" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
	
#    		?this rdf:type ?subC . 
#    		?subC rdfs:subClassOf* ?C .
#           -----

			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
	
#		    ?this ?subDPE ?object .	
#		    ?subDPE rdfs:subPropertyOf* ?DPE .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subDPE" ] ;
				sp:object [ sp:varName "object" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subDPE" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subPropertyOf ] ;
			    sp:object [ sp:varName "DPE" ] ]
				
#    		FILTER ( sp:not ( spl:instanceOf ( ?object, ?DR ) ) ) . 
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:instanceOf ;
				        sp:arg1 [ sp:varName "object" ] ;
						sp:arg2 [ sp:varName "DR" ] ] ] ]
				
#           DPE is data property expression	
#           -----
#           FILTER NOT EXISTS { ?this ?DPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
				
#    		BIND ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataAllValuesFrom ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ].
	
# -----	

# ---------------
# DataHasValue


# description
# -----


# definition
# -----
# DataHasValue := 'DataHasValue' '(' DataPropertyExpression Literal ')' 

# SPIN template:
# -----
owl2:DataHasValue
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataHasValue" ;
	rdfs:label "DataHasValue" ;
	rdfs:comment "DataHasValue" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object [ sp:varName "property" ] ] );
		sp:where (  
#       WHERE {
#		    ?this rdf:type ?subC . 
#		    ?subC rdfs:subClassOf* ?C . 
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#	        ?C rdf:type owl:Restriction ;
#   	    ?C owl:onProperty ?DPE ;
#       	?C owl:hasValue ?L . 
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:hasValue ;
				sp:object [ sp:varName "L" ] ]
			
#           FILTER ( sp:not ( spl:hasValue ( ?this, ?DPE, ?L ) ) ) .
#           -----			
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValue ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "DPE" ] ;
						sp:arg3 [ sp:varName "L" ] ] ] ]

#           DPE is data property expression	
#           -----
#           FILTER NOT EXISTS { ?this ?DPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataHasValue ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Equivalent Classes ( class expression axioms )


# description
# -----
# An equivalent classes axiom EquivalentClasses( CE1 ... CEn ) states that all of the class expressions CEi, 1 ≤ i ≤ n, are semantically equivalent to each other. 
# This axiom allows one to use each CEi as a synonym for each CEj — that is, in any expression in the ontology containing such an axiom, 
# CEi can be replaced with CEj without affecting the meaning of the ontology.

# definition
# -----	
# EquivalentClasses := 'EquivalentClasses' '(' axiomAnnotations ClassExpression ClassExpression { ClassExpression } ')' 

# examples
# -----


# SPIN template
# -----


# -----

# ---------------
# Disjoint Classes ( class expression axioms )


# description
# -----
# A disjoint classes axiom DisjointClasses( CE1 ... CEn ) states that all of the class expressions CEi, 1 ≤ i ≤ n, are pairwise disjoint; 
# that is, no individual can be at the same time an instance of both CEi and CEj for i ≠ j. 

# definition
# -----	
# DisjointClasses := 'DisjointClasses' '(' axiomAnnotations ClassExpression ClassExpression { ClassExpression } ')'  

# examples
# -----
# DisjointClasses( a:Boy a:Girl ) 
# a:Boy owl:disjointWith a:Girl . 
# a:Stewie 
#     rdf:type a:Boy ; 
#     rdf:type a:Girl . 

# DisjointClasses ( a:Male a:Female a:Hybrid )
# a:Male owl:disjointWith a:Female . 
# a:Male owl:disjointWith a:Hybrid .
# a:Hybrid owl:disjointWith a:Female .
# a:M_1 
#	  rdf:type a:Male ;
#	  rdf:type a:Female .
# a:M_2
#	  rdf:type a:Male ;
#	  rdf:type a:Hybrid .
# a:M_3
#	  rdf:type a:Female ;
#	  rdf:type a:Hybrid .

# SPIN template
# -----
owl2:DisjointClasses
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DisjointClasses" ;
	rdfs:label "DisjointClasses" ;
	rdfs:comment "DisjointClasses" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?violationPath ;
#               spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "CE1" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object owl2:DisjointClasses ] ) ;
#		WHERE {
#           ?this rdf:type ?CE_1 .
#           ?this rdf:type ?CE_2 .
#		    ?CE1 owl:disjointWith ?CE2 .
#           FILTER ( ?CE_1 = ?CE1 ) .
#           FILTER ( ?CE_2 = ?CE2 ) .
#           FILTER ( ?CE_1 != ?CE_2 ) .  
#		    LET ( ( ... ) AS ?label ) . }
		sp:where ( 
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "CE_1" ] ]
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "CE_2" ] ]	
			[   sp:subject [ sp:varName "CE1" ] ;
			    sp:predicate owl:disjointWith ;
				sp:object [ sp:varName "CE2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "CE_1" ] ;
					sp:arg2 [ sp:varName "CE1" ] ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "CE_2" ] ;
					sp:arg2 [ sp:varName "CE2" ] ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "CE_1" ] ;
					sp:arg2 [ sp:varName "CE_2" ] ] ]		
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DisjointClasses ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " )" ] ] ) ] .
					
# -----

# ---------------
# Disjoint Union ( of Class Expressions ) ( class expression axioms )


# description
# -----
# A disjoint union axiom DisjointUnion( C CE1 ... CEn ) states that a class C is a disjoint union of the class expressions CEi, 1 ≤ i ≤ n, 
# all of which are pairwise disjoint. Such axioms are sometimes referred to as covering axioms, 
# as they state that the extensions of all CEi exactly cover the extension of C. 
# Thus, each instance of C is an instance of exactly one CEi, and each instance of CEi is an instance of C. 

# definition
# -----	
# DisjointUnion := 'DisjointUnion' '(' axiomAnnotations Class disjointClassExpressions ')'
# disjointClassExpressions := ClassExpression ClassExpression { ClassExpression } 

# example ( 2 disjoint class expressions )
# -----
# DisjointUnion( a:Child a:Boy a:Girl ) 
# a:Child owl:disjointUnionOf ( a:Boy a:Girl ) .

# DisjointUnion( a:DisjointUnion_C a:DisjointUnion_CE1 a:DisjointUnion_CE2 ) 
# a:DisjointUnion_C1 owl:disjointUnionOf ( a:DisjointUnion_CE1 a:DisjointUnion_CE2 ) . 
# a:DisjointUnion_I1 
#	rdf:type a:DisjointUnion_C1 ;
#	rdf:type a:DisjointUnion_CE1 ;
#	rdf:type a:DisjointUnion_CE2 .
# a:DisjointUnion_I2 
#	rdf:type owl:Thing ;
#	rdf:type a:DisjointUnion_C1 ;
#	rdf:type a:DisjointUnion_CE1 .
# a:DisjointUnion_I3 
#	rdf:type owl:Thing ;
#	rdf:type a:DisjointUnion_C1 ;
#	rdf:type a:DisjointUnion_CE2 .

# example ( 3 disjoint class expressions )
# -----


# SPIN templates
# -----

# 2 disjoint class expressions
#	CONSTRUCT {
#	    _:violation 
#			a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#	    ?C owl:disjointUnionOf ( ?CE1 CE2 ) . 
#       -----
#	    ?C owl:disjointUnionOf ?disjointClassExpressions .
#	    ?disjointClassExpressions rdf:first ?CE1 .
#	    ?disjointClassExpressions rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#	    ?this rdf:type ?C .
#
#	    each instance of C is an instance of exactly one CEi
#       -----
#	    ?this rdf:type ?CE1 .
#		?this rdf:type ?CE2 .
#
#		LET ( ( ... ) AS ?label ) . }
owl2:DisjointUnion_2DisjointClassExpressions_1 
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Disjoint Union of Class Expressions" ;
	rdfs:label "Disjoint Union of Class Expressions" ;
	rdfs:comment "Disjoint Union of Class Expressions" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where (
#	    	?C owl:disjointUnionOf ( ?CE1 CE2 ) . 
#       	-----
#	    	?C owl:disjointUnionOf ?disjointClassExpressions .
#	    	?disjointClassExpressions rdf:first ?CE1 .
#	    	?disjointClassExpressions rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .				
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:disjointUnionOf ;
				sp:object [ sp:varName "?disjointClassExpressions" ] ]
			[   sp:subject [ sp:varName "disjointClassExpressions" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "disjointClassExpressions" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]
					
#           ?this rdf:type ?C .
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]
					
#	    	each instance of C is an instance of exactly one CEi
#       	-----
#	    	?this rdf:type ?CE1 .
#			?this rdf:type ?CE2 .
#			[   sp:subject [ sp:varName "this" ] ;
#			    sp:predicate rdf:type ;
#				sp:object [ sp:varName "CE1" ] ]
#			[   sp:subject [ sp:varName "this" ] ;
#			    sp:predicate rdf:type ;
#				sp:object [ sp:varName "CE2" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE1" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE2" ] ] ) ] ]
				
#		    LET ( ( ... ) AS ?label ) .					
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 [ sp:varName "C" ] ;
					sp:arg2 " owl:disjointUnionOf ( " ;
					sp:arg3 [ sp:varName "CE1" ] ;
					sp:arg4 " " ;
					sp:arg5 [ sp:varName "CE2" ] ;
					sp:arg6 " )" ] ] ) ] .
				
#	CONSTRUCT {
#	    _:violation 
#           a spin:ConstraintViolation ;
#	        rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#	    ?C owl:disjointUnionOf ( ?CE1 CE2 ) . 
#       -----
#	    ?C owl:disjointUnionOf ?disjointClassExpressions .
#	    ?disjointClassExpressions rdf:first ?CE1 .
#	    ?disjointClassExpressions rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#       ?this rdf:type ?CE1
#
#       each instance of CE1 is an instance of C
#       -----
#       FILTER NOT EXISTS { ?this rdf:type ?C }
#
#		LET ( ( ... ) AS ?label ) . }			
owl2:DisjointUnion_2DisjointClassExpressions_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Disjoint Union of Class Expressions" ;
	rdfs:label "Disjoint Union of Class Expressions" ;
	rdfs:comment "Disjoint Union of Class Expressions" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where (
#	    	?C owl:disjointUnionOf ( ?CE1 CE2 ) . 
#       	-----
#	    	?C owl:disjointUnionOf ?disjointClassExpressions .
#	    	?disjointClassExpressions rdf:first ?CE1 .
#	    	?disjointClassExpressions rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .			
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:disjointUnionOf ;
				sp:object [ sp:varName "?disjointClassExpressions" ] ]
			[   sp:subject [ sp:varName "disjointClassExpressions" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "disjointClassExpressions" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]

#           ?this rdf:type ?CE1
            [   sp:subject spin:_this ;
				sp:predicate rdf:type ;
				sp:object [ sp:varName "CE1" ] ]

#           each instance of CE1 is an instance of C
#           -----
#           FILTER NOT EXISTS { ?this rdf:type ?C }
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "C" ] ] ) ] ]
				
#           workaround ( ObjectIntersectionOf )
#       	-----
#			[   sp:subject [ sp:varName "C_" ] ;
#			    sp:predicate rdf:type ;
#				sp:object owl:Class ]
#			[   sp:subject [ sp:varName "C_" ] ;
#			    sp:predicate owl:intersectionOf ;
#				sp:object [ sp:varName "CEs_" ] ]
#			[   sp:subject [ sp:varName "CEs_" ] ;
#			    sp:predicate rdf:first ;
#				sp:object [ sp:varName "CE_1" ] ]
#			[   sp:subject [ sp:varName "CEs_" ] ;
#			    sp:predicate rdf:rest ;
#				sp:object [ sp:varName "rest_1_" ] ]
#			[   sp:subject [ sp:varName "rest_1_" ] ;
#			    sp:predicate rdf:first ;
#				sp:object [ sp:varName "CE_2" ] ]
#			[   sp:subject [ sp:varName "rest_1_" ] ;
#			    sp:predicate rdf:rest ;
#				sp:object [ sp:varName "rest_2_" ] ]
#			[   a sp:Filter;
#				sp:expression [ 
#					a sp:eq;
#				    sp:arg1 [ sp:varName "rest_2_" ];
#					sp:arg2 rdf:nil ] ]	
#			[   a sp:Filter ;
#                sp:expression [
#			        a sp:notExists ;
#                    sp:elements (
#						[   sp:subject [ sp:varName "this" ] ;
#			                sp:predicate rdf:type ;
#				            sp:object [ sp:varName "CE_1" ] ] ) ] ]
#			[   a sp:Filter ;
#                sp:expression [
#			        a sp:notExists ;
#                    sp:elements (
#						[   sp:subject [ sp:varName "this" ] ;
#			                sp:predicate rdf:type ;
#				            sp:object [ sp:varName "CE_2" ] ] ) ] ]
				
#		    LET ( ( ... ) AS ?label ) .					
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 [ sp:varName "C" ] ;
					sp:arg2 " owl:disjointUnionOf ( 2 ) ( " ;
					sp:arg3 [ sp:varName "CE1" ] ;
					sp:arg4 " " ;
					sp:arg5 [ sp:varName "CE2" ] ;
					sp:arg6 " )" ] ] ) ] .

#	CONSTRUCT {
#	    _:violation 
#           a spin:ConstraintViolation ;
#	        rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#	    ?C owl:disjointUnionOf ( ?CE1 CE2 ) . 
#       -----
#	    ?C owl:disjointUnionOf ?disjointClassExpressions .
#	    ?disjointClassExpressions rdf:first ?CE1 .
#	    ?disjointClassExpressions rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#       ?this rdf:type ?CE2
#
#       each instance of CE2 is an instance of C
#       -----
#       FILTER NOT EXISTS { ?this rdf:type ?C }
#
#		LET ( ( ... ) AS ?label ) . }		
owl2:DisjointUnion_2DisjointClassExpressions_3
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Disjoint Union of Class Expressions" ;
	rdfs:label "Disjoint Union of Class Expressions" ;
	rdfs:comment "Disjoint Union of Class Expressions" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where (
#	    	?C owl:disjointUnionOf ( ?CE1 CE2 ) . 
#       	-----
#	    	?C owl:disjointUnionOf ?disjointClassExpressions .
#	    	?disjointClassExpressions rdf:first ?CE1 .
#	    	?disjointClassExpressions rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .				
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:disjointUnionOf ;
				sp:object [ sp:varName "?disjointClassExpressions" ] ]
			[   sp:subject [ sp:varName "disjointClassExpressions" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "disjointClassExpressions" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]
			
#           ?this rdf:type ?CE2
            [   sp:subject spin:_this ;
				sp:predicate rdf:type ;
				sp:object [ sp:varName "CE2" ] ]

#       	each instance of CE2 is an instance of C
#       	-----
#       	FILTER NOT EXISTS { ?this rdf:type ?C }
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "C" ] ] ) ] ]
							
#           workaround ( ObjectIntersectionOf )
#       	-----
#			[   sp:subject [ sp:varName "C_" ] ;
#			    sp:predicate rdf:type ;
#				sp:object owl:Class ]
#			[   sp:subject [ sp:varName "C_" ] ;
#			    sp:predicate owl:intersectionOf ;
#				sp:object [ sp:varName "CEs_" ] ]
#			[   sp:subject [ sp:varName "CEs_" ] ;
#			    sp:predicate rdf:first ;
#				sp:object [ sp:varName "CE_1" ] ]
#			[   sp:subject [ sp:varName "CEs_" ] ;
#			    sp:predicate rdf:rest ;
#				sp:object [ sp:varName "rest_1_" ] ]
#			[   sp:subject [ sp:varName "rest_1_" ] ;
#			    sp:predicate rdf:first ;
#				sp:object [ sp:varName "CE_2" ] ]
#			[   sp:subject [ sp:varName "rest_1_" ] ;
#			    sp:predicate rdf:rest ;
#				sp:object [ sp:varName "rest_2_" ] ]
#			[   a sp:Filter;
#				sp:expression [ 
#					a sp:eq;
#				    sp:arg1 [ sp:varName "rest_2_" ];
#					sp:arg2 rdf:nil ] ]	
#			[   a sp:Filter ;
#                sp:expression [
#			        a sp:notExists ;
#                    sp:elements (
#						[   sp:subject [ sp:varName "this" ] ;
#			                sp:predicate rdf:type ;
#				            sp:object [ sp:varName "CE_1" ] ] ) ] ]	
#			[   a sp:Filter ;
#                sp:expression [
#			        a sp:notExists ;
#                    sp:elements (
#						[   sp:subject [ sp:varName "this" ] ;
#			                sp:predicate rdf:type ;
#				            sp:object [ sp:varName "CE_2" ] ] ) ] ]
					
#		    LET ( ( ... ) AS ?label ) .					
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 [ sp:varName "C" ] ;
					sp:arg2 " owl:disjointUnionOf (3) ( " ;
					sp:arg3 [ sp:varName "CE1" ] ;
					sp:arg4 " " ;
					sp:arg5 [ sp:varName "CE2" ] ;
					sp:arg6 " )" ] ] ) ] .
					
# -----

# ---------------
# SubObjectPropertyOf ( object property axioms )


# description
# -----
# This axiom states that the object property expression OPE1 is a subproperty of the object property expression OPE2 -
# that is, if an individual x is connected by OPE1 to an individual y, then x is also connected by OPE2 to y. 

# definition
# -----
# SubObjectPropertyOf := 'SubObjectPropertyOf' '(' axiomAnnotations subObjectPropertyExpression superObjectPropertyExpression ')'	

# SPIN template:
# -----
owl2:SubObjectPropertyOf
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "SubObjectPropertyOf" ;
	rdfs:label "SubObjectPropertyOf" ;
	rdfs:comment "SubObjectPropertyOf" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?property }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object [ sp:varName "subOPE" ] ] );
		sp:where ( 
#       WHERE {
#		    ?subOPE rdfs:subPropertyOf ?superOPE .
#           -----
			[   sp:subject [ sp:varName "subOPE" ] ;
			    sp:predicate rdfs:subPropertyOf ;
				sp:object [ sp:varName "superOPE" ] ]
				
#           ?this ?subOPE ?y .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subOPE" ] ;
				sp:object [ sp:varName "y" ] ]
			
				
#           FILTER NOT EXISTS { ?this ?superOPE ?y } .	
#           -----
            [   a sp:Filter ;
                sp:expression [
				    a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "superOPE" ] ;
                            sp:object [ sp:varName "y" ] ] ) ] ] 
							
#		    BIND ( ( ... ) AS ?label ) . }	
#           -----								
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "SubObjectPropertyOf ( " ;
					sp:arg2 [ sp:varName "subOPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "superOPE" ] ] ] ) ] .

# -----

# ---------------
# ObjectPropertyChain ( object property axioms )


# description
# -----
# if an individual x is connected by a sequence of object property expressions OPE1, ..., OPEn with an individual y, 
# then x is also connected with y by the object property expression OPE.

# definition
# -----	
# SubObjectPropertyOf ( axiomAnnotations ObjectPropertyChain ( ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ) superObjectPropertyExpression )

# SPIN template:
# -----
owl2:ObjectPropertyChain_2OPE
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectPropertyChain" ;
	rdfs:label "ObjectPropertyChain" ;
	rdfs:comment "ObjectPropertyChain" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?violationPath ;
#               spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "superOPE" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object owl2:ObjectPropertyChain_TwoObjectPropertyExpressions ] ) ;
		sp:where ( 
#		WHERE {
#		    ?superOPE owl:propertyChainAxiom ?objectPropertyChain .
#           -----
#			?objectPropertyChain rdf:first ?first_1 .
#			?objectPropertyChain rdf:rest ?rest_1 .
#			?rest_1 rdf:first ?first_2 .
#			?rest_1 rdf:rest ?rest_2 .
#           FILTER ( ?rest_2 = rdf:nil )	
			
			[   sp:subject [ sp:varName "superOPE" ] ;
			    sp:predicate owl:propertyChainAxiom ;
				sp:object [ sp:varName "objectPropertyChain" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE1" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]
					
#           ?this ?OPE1 ?a . ?a ?OPE2 ?b
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ]
			[   sp:subject [ sp:varName "a" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "b" ] ]
		
#           FILTER NOT EXISTS { ?this ?superOPE ?b } .  
#           -----		
            [   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "superOPE" ] ;
				            sp:object [ sp:varName "b" ] ] ) ] ]
							
#    		BIND ( ... ) AS ?label ) . }
#           -----			
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "SubObjectPropertyOf( ObjectPropertyChain( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " ) " ;
					sp:arg6 [ sp:varName "superOPE" ] ;
					sp:arg7 " )" ] ] ) ] .
					
owl2:ObjectPropertyChain_3OPE
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectPropertyChain" ;
	rdfs:label "ObjectPropertyChain" ;
	rdfs:comment "ObjectPropertyChain" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?violationPath ;
#               spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "superOPE" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object owl2:ObjectPropertyChain_ThreeObjectPropertyExpressions ] ) ;
		sp:where ( 
#       WHERE {
#		    ?superOPE owl:propertyChainAxiom ( ?OPE1 ?OPE2 ?OPE3 ) .
#           -----
			[   sp:subject [ sp:varName "superOPE" ] ;
			    sp:predicate owl:propertyChainAxiom ;
				sp:object [ sp:varName "objectPropertyChain" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE1" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE3" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_3" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_3" ];
					sp:arg2 rdf:nil ] ]
					
#           ?this ?OPE1 ?a . ?a ?OPE2 ?b . ?b ?OPE2 ?c .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ]
			[   sp:subject [ sp:varName "a" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "b" ] ]	
			[   sp:subject [ sp:varName "b" ] ;
			    sp:predicate [ sp:varName "OPE3" ] ;
				sp:object [ sp:varName "c" ] ]	
					
#           FILTER NOT EXISTS { ?this ?superOPE ?c } . 
            [   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "superOPE" ] ;
				            sp:object [ sp:varName "c" ] ] ) ] ]
							
#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "SubObjectPropertyOf( ObjectPropertyChain( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "OPE3" ] ;
					sp:arg7 " ) " ;
					sp:arg8 [ sp:varName "superOPE" ] ;
					sp:arg9 " )" ] ] ) ] .

# -----

# ---------------
# EquivalentObjectProperties


# description
# -----
# An equivalent object properties axiom EquivalentObjectProperties( OPE1 ... OPEn ) states that all of the object property expressions OPEi, 1 ≤ i ≤ n, 
# are semantically equivalent to each other. This axiom allows one to use each OPEi as a synonym for each OPEj — 
# that is, in any expression in the ontology containing such an axiom, OPEi can be replaced with OPEj without affecting the meaning of the ontology.

# definition
# -----	
# EquivalentObjectProperties := 'EquivalentObjectProperties' '(' axiomAnnotations ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ')' 

owl:Thing
    spin:rule [
        a sp:Construct ;
		rdfs:comment "EquivalentObjectProperties" ;
		sp:templates ( 
#           ?this ?OPE2 ?a
#           -----		
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "a" ] ] ) ;
		sp:where (
#       WHERE {
#		    ?OPE1 owl:equivalentProperty ?OPE2 . 
#           -----	
			[   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:equivalentProperty ;
				sp:object [ sp:varName "OPE2" ] ]
				
#           ?this ?OPE1 ?a
#           -----	
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ] ) ] ; 
				
    spin:rule [
        a sp:Construct ;
		rdfs:comment "EquivalentObjectProperties" ;
		sp:templates ( 
#           ?this ?OPE1 ?a
#           -----		
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ] ) ;
		sp:where (
#       WHERE {
#		    ?OPE1 owl:equivalentProperty ?OPE2 . 
#           -----	
			[   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:equivalentProperty ;
				sp:object [ sp:varName "OPE2" ] ]
				
#           ?this ?OPE2 ?a
#           -----	
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "a" ] ] ) ] .

# -----

# ---------------
# DisjointObjectProperties


# description
# -----
# A disjoint object properties axiom DisjointObjectProperties( OPE1 ... OPEn ) states that all of the object property expressions OPEi, 1 ≤ i ≤ n, 
# are pairwise disjoint; that is, no individual x can be connected to an individual y by both OPEi and OPEj for i ≠ j. 

# definition
# -----	
# DisjointObjectProperties := 'DisjointObjectProperties' '(' axiomAnnotations ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ')' 

# SPIN templates:
# -----
owl2:DisjointObjectProperties
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DisjointObjectProperties" ;
	rdfs:label "DisjointObjectProperties" ;
	rdfs:comment "DisjointObjectProperties" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?violationPath ;
#               spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "superOPE" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object owl2:ObjectPropertyChain_TwoObjectPropertyExpressions ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE1 owl:propertyDisjointWith ?OPE2 . 
#           -----	
			[   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:propertyDisjointWith ;
				sp:object [ sp:varName "OPE2" ] ]
				
#           { ?this ?OPE1 ?y . FILTER EXISTS { ?this ?OPE2 ?y } } 
#           UNION
#           { ?this ?OPE2 ?y . FILTER NOT EXISTS { ?this ?OPE1 ?y } } 
#           -----
			[   a sp:Union ;
                sp:elements ( 
					(   [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "OPE1" ] ;
                            sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter ;
                            sp:expression [
 							    a sp:exists ;
                                sp:elements ( 
									[   sp:subject [ sp:varName "this" ] ;
                                        sp:predicate [ sp:varName "OPE2" ] ;
                                        sp:object [ sp:varName "y" ] ] ) ] ] ) 
					(   [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "OPE2" ] ;
                            sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter ;
                            sp:expression [
 							    a sp:exists ;
                                sp:elements ( 
									[   sp:subject [ sp:varName "this" ] ;
                                        sp:predicate [ sp:varName "OPE1" ] ;
                                        sp:object [ sp:varName "y" ] ] ) ] ] ) ) ] 
							
#    		BIND ( ... ) AS ?label ) . }
#           -----			
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DisjointObjectProperties ( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# InverseObjectProperties


# description
# -----
# An inverse object properties axiom InverseObjectProperties( OPE1 OPE2 ) states that the object property expression OPE1 
# is an inverse of the object property expression OPE2. Thus, if an individual x is connected by OPE1 to an individual y, 
# then y is also connected by OPE2 to x, and vice versa. 

# definition
# -----	
# InverseObjectProperties := 'InverseObjectProperties' '(' axiomAnnotations ObjectPropertyExpression ObjectPropertyExpression ')' 

# SPIN templates
# -----
owl2:InverseObjectProperties
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "InverseObjectProperties" ;
	rdfs:label "InverseObjectProperties" ;
	rdfs:comment "InverseObjectProperties" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE1 owl:inverseOf ?OPE2 . 
#           -----
            [   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:inverseOf ;
				sp:object [ sp:varName "OPE2" ] ]

#           { ?this ?OPE1 ?y . FILTER NOT EXISTS { ?y ?OPE2 ?this } } 
#           UNION
#           { ?this ?OPE2 ?y . FILTER NOT EXISTS { ?y ?OPE1 ?this } } 
#           -----
			[   a sp:Union ;
                sp:elements ( 
					(   [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "OPE1" ] ;
                            sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter ;
                            sp:expression [
 							    a sp:notExists ;
                                sp:elements ( 
									[   sp:subject [ sp:varName "y" ] ;
                                        sp:predicate [ sp:varName "OPE2" ] ;
                                        sp:object [ sp:varName "this" ] ] ) ] ] ) 
					(   [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "OPE2" ] ;
                            sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter ;
                            sp:expression [
 							    a sp:notExists ;
                                sp:elements ( 
									[   sp:subject [ sp:varName "y" ] ;
                                        sp:predicate [ sp:varName "OPE1" ] ;
                                        sp:object [ sp:varName "this" ] ] ) ] ] ) ) ] 

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "InverseObjectProperties ( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Object Property Domain ( object property axioms )


# description
# -----
# An object property domain axiom ObjectPropertyDomain( OPE CE ) states that the domain of the object property expression OPE is the class expression CE — 
# that is, if an individual x is connected by OPE with some other individual, then x is an instance of CE. 

# definition
# -----	
# ObjectPropertyDomain := 'ObjectPropertyDomain' '(' axiomAnnotations ObjectPropertyExpression ClassExpression ')' 

# SPIN templates:
# -----
#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?OPE rdfs:domain ?CE . 
#       ?this ?OPE ?y .
#	    FILTER EXISTS { ?y rdf:type owl:Thing }
#       FILTER NOT EXISTS ( ?this rdf:type ?CE ) .
#		LET ( ( ... ) AS ?label ) . }
owl2:ObjectPropertyDomain
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Object Property Domain" ;
	rdfs:label "Object Property Domain" ;
	rdfs:comment "Object Property Domain" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdfs:domain ;
				sp:object [ sp:varName "CE" ] ]
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "OPE" ] ;
                sp:object [ sp:varName "y" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectPropertyDomain ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Object Property Range ( object property axioms ) 


# description
# -----
# An object property range axiom ObjectPropertyRange( OPE CE ) states that the range of the object property expression OPE is the class expression CE — 
# that is, if some individual is connected by OPE with an individual x, then x is an instance of CE. 

# definition
# -----	
# ObjectPropertyRange := 'ObjectPropertyRange' '(' axiomAnnotations ObjectPropertyExpression ClassExpression ')' 

# SPIN templates:
# -----
#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?OPE rdfs:range ?CE . 
#       ?this ?OPE ?y .
#	    FILTER EXISTS { ?y rdf:type owl:Thing }
#       FILTER NOT EXISTS ( ?y rdf:type ?CE ) .
#		LET ( ( ... ) AS ?label ) . }
owl2:ObjectPropertyRange
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Object Property Range" ;
	rdfs:label "Object Property Range" ;
	rdfs:comment "Object Property Range" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdfs:range ;
				sp:object [ sp:varName "CE" ] ]		
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "OPE" ] ;
                sp:object [ sp:varName "y" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectPropertyRange ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Functional Object Properties 


# description
# -----
# An object property functionality axiom FunctionalObjectProperty( OPE ) states that the object property expression OPE is functional — 
# that is, for each individual x, there can be at most one distinct individual y such that x is connected by OPE to y. 

# definition
# -----	
# FunctionalObjectProperty := 'FunctionalObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')' 

# SPIN templates:
# -----
owl2:FunctionalObjectProperty
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "FunctionalObjectProperty" ;
	rdfs:label "FunctionalObjectProperty" ;
	rdfs:comment "FunctionalObjectProperty" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE rdf:type owl:FunctionalProperty . 
#           -----
            [   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:FunctionalProperty ]

#           ?this ?OPE ?x .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE" ] ;
				sp:object [ sp:varName "x" ] ]
				
#           FILTER EXISTS { ?this ?OPE ?y . FILTER ( ?x != ?y ) . } .
#           -----
			[   a sp:Filter ;
				sp:expression [
					a sp:exists ;
					sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "OPE" ] ;
							sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "x" ];
								sp:arg2 [ sp:varName "y" ] ] ] ) ] ]

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "FunctionalProperty ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Inverse-Functional Object Properties


# description
# -----
# An object property inverse functionality axiom InverseFunctionalObjectProperty( OPE ) states that the object property expression OPE is inverse-functional — 
# that is, for each individual x, there can be at most one individual y such that y is connected by OPE with x. 

# definition
# -----	
# InverseFunctionalObjectProperty := 'InverseFunctionalObjectProperty' '(' axiomAnnotations ObjectPropertyExpression ')' 

# SPIN templates:
# -----
owl2:InverseFunctionalObjectProperty
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "InverseFunctionalObjectProperty" ;
	rdfs:label "InverseFunctionalObjectProperty" ;
	rdfs:comment "InverseFunctionalObjectProperty" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE rdf:type owl:InverseFunctionalProperty . 
#           -----
            [   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:InverseFunctionalProperty ]

#           ?x ?OPE ?this .
#           -----
			[   sp:subject [ sp:varName "x" ] ;
			    sp:predicate [ sp:varName "OPE" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER EXISTS { ?y ?OPE ?this . FILTER ( ?x != ?y ) . } .
#           -----
			[   a sp:Filter ;
				sp:expression [
					a sp:exists ;
					sp:elements ( 
						[   sp:subject [ sp:varName "y" ] ;
							sp:predicate [ sp:varName "OPE" ] ;
							sp:object [ sp:varName "this" ] ] 
						[   a sp:Filter;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "x" ];
								sp:arg2 [ sp:varName "y" ] ] ] ) ] ]

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "InverseFunctionalProperty ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Data Property Domain


# description
# -----
# A data property domain axiom DataPropertyDomain( DPE CE ) states that the domain of the data property expression DPE is the class expression CE — 
# that is, if an individual x is connected by DPE with some literal, then x is an instance of CE.

# definition
# -----	
# DataPropertyDomain := 'DataPropertyDomain' '(' axiomAnnotations DataPropertyExpression ClassExpression ')' 

# SPIN templates:
# -----
#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?DPE rdfs:domain ?DR . 
#	    ?this ?DPE ?y . 
#       FILTER NOT EXISTS ( ?y rdf:type owl:Thing . ) .
#       FILTER NOT EXISTS ( ?this rdf:type ?DR ) .
#		LET ( ( ... ) AS ?label ) . }
owl2:DataPropertyDomain
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Data Property Domain" ;
	rdfs:label "Data Property Domain" ;
	rdfs:comment "Data Property Domain" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "DPE" ] ;
			    sp:predicate rdfs:domain ;
				sp:object [ sp:varName "DR" ] ]		
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "DPE" ] ;
                sp:object [ sp:varName "y" ] ]	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object owl:Thing ] ) ] ]	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "DR" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataPropertyDomain ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Data Property Range


# description
# -----
# A data property range axiom DataPropertyRange( DPE DR ) states that the range of the data property expression DPE is the data range DR — 
# that is, if some individual is connected by DPE with a literal x, then x is in DR.

# definition
# -----	
# DataPropertyRange := 'DataPropertyRange' '(' axiomAnnotations DataPropertyExpression DataRange ')' 

# SPIN templates:
# -----
#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?DPE rdfs:range ?DR . 
#	    ?this ?DPE ?y . 
#       FILTER NOT EXISTS ( ?y rdf:type owl:Thing . ) .
#       FILTER NOT EXISTS ( ?y rdf:type ?DR ) .
#		LET ( ( ... ) AS ?label ) . }
owl2:DataPropertyRange
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Data Property Range" ;
	rdfs:label "Data Property Range" ;
	rdfs:comment "Data Property Range" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "DPE" ] ;
			    sp:predicate rdfs:range ;
				sp:object [ sp:varName "DR" ] ]		
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "DPE" ] ;
                sp:object [ sp:varName "y" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object owl:Thing ] ) ] ]	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "DR" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataPropertyRange ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# DatatypeDefinition


# description
# -----
# A datatype definition DatatypeDefinition( DT DR ) defines a new datatype DT as being semantically equivalent to the data range DR; 
# the latter MUST be a unary data range. This axiom allows one to use the defined datatype DT as a synonym for DR — 
# that is, in any expression in the ontology containing such an axiom, DT can be replaced with DR without affecting the meaning of the ontology.

# definition
# -----	
# DatatypeDefinition := 'DatatypeDefinition' '(' axiomAnnotations Datatype DataRange ')' 

# SPIN templates:
# -----
owl2:DatatypeDefinition_Pattern
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DatatypeDefinition" ;
	rdfs:label "DatatypeDefinition" ;
	rdfs:comment "DatatypeDefinition" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this ?DPE ?L .
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . 
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype .
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]
					
#           ?DT owl:equivalentClass ?EC .
#           ?EC rdf:type rdfs:Datatype .
#           ?EC owl:onDatatype xsd:string .
#           ?EC owl:withRestrictions ?list .
#           ?list rdf:first ?e1 .
#           ?e1 xsd:pattern ?pattern .
#           ?list rdf:rest ?R1 .
#           FILTER ( ?R1 = rdf:nil ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:onDatatype ;
				sp:object xsd:string ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:withRestrictions ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "e1" ] ]
			[   sp:subject [ sp:varName "e1" ] ;
			    sp:predicate xsd:pattern ;
				sp:object [ sp:varName "pattern" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R1" ];
					sp:arg2 rdf:nil ] ]
	
#           FILTER( fn:matches ( ?L_str, ?pattern ) = "false"^^xsd:boolean ) . 	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [
							a fn:matches; 
							sp:arg1 [ sp:varName "L_str" ] ;
							sp:arg2 [ sp:varName "pattern" ] ] ;
					sp:arg2 "false"^^xsd:boolean ] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "L: " ;
#					sp:arg2 [ sp:varName "L" ] ;
#					sp:arg3 " | datatype (L): " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | DT: " ;
#					sp:arg6 [ sp:varName "DT" ] ;
#					sp:arg7 " | pattern: " ;
#					sp:arg8 [ sp:varName "pattern" ] ;
#					sp:arg9 " | matches: " ;
#					sp:arg10 [ sp:varName "matches" ] ;
#					sp:arg11 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "String '" ;
					sp:arg2 [ sp:varName "L_str" ] ;
					sp:arg3 "' does not match the pattern '" ;
					sp:arg4 [ sp:varName "pattern" ] ;
					sp:arg5 "'" ] ] ) ] .
					
# -----