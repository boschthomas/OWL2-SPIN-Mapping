# namespace declarations
# -----
@prefix fn:        <http://www.w3.org/2005/xpath-functions#> .
@prefix sparql:    <http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#> .
@prefix xsd:       <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:       <http://www.w3.org/2002/07/owl#> .
@prefix sp:        <http://spinrdf.org/sp#> .
@prefix spin:      <http://spinrdf.org/spin#> .
@prefix smf:       <http://topbraid.org/sparqlmotionfunctions#> .
@prefix spif:      <http://spinrdf.org/spif#> . 
@prefix spl:       <http://spinrdf.org/spl#> .
@prefix spinowl:   <http://topbraid.org/spin/spinowl> .
@prefix spinx:     <http://spinrdf.org/spinx#> . 
@prefix functions: <http://www.example.org/functions#> .
@prefix templates: <http://www.example.org/templates#> .
@prefix sparql:    <http://www.w3.org/TR/sparql11-query/#> .
@prefix owl2spin:  <http://constraints.org/owl2#> .

# namespace descriptions
# -----
# sp:
# - syntactically represent SPARQL queries and update commands as RDF triples
# spin:
# - attach constraints and rules to RDFS classes
# - encapsulate reusable SPARQL queries into functions and templates
# spif:
# - generally useful SPARQL functions defined using SPIN
# - functions that are impossible or difficult to express in terms of other functions, but rather will require a native implementation in languages like Java
# spl:
# - SPIN Standard Modules Library (SPL)
# - generally useful SPARQL functions (expressed as SPIN functions), and SPIN templates
# - top-level classification of functions, and definitions of the standard SPARQL functions
# - functions that can be expressed entirely in terms of other SPARQL expressions and standard built-ins
# spinowl:
# - constraint checking axioms for a subset of OWL, using closed-world semantics

# ontology
# -----
<constraints/owl> 
	a owl:Ontology ;
	rdfs:comment "OWL 2 constraint checking axioms, using closed-world semantics." ;
	owl:imports <http://spinrdf.org/spl> ;
	owl:imports <http://www.w3.org/2005/xpath-functions> ;
#	owl:imports <http://topbraid.org/sparqlmotionfunctions> ;
#	owl:import <http://spinrdf.org/spif> ;
	owl:versionInfo "0.0.1" .

# ---------------
# class constraints: 
	
owl:Thing 
	spin:constraint 
	
		# Data Ranges - Set-Oriented Operations
		# -----
		# Enumeration of Literals 
		[   a owl2spin:DataOneOf_1L ] , 
		[   a owl2spin:DataOneOf_2L ] , 
		[   a owl2spin:DataOneOf_3L ] , 
		[   a owl2spin:DataOneOf_4L ] , 
		[   a owl2spin:DataOneOf_5L ] ,
		
		# Class Expressions - Set-Oriented Operations
		# -----
		# Intersection of Class Expressions 
		[   a owl2spin:ObjectIntersectionOf_2CE ] ,
		[   a owl2spin:ObjectIntersectionOf_3CE ] ,
		# Union of Class Expressions 
		[   a owl2spin:ObjectUnionOf_2CE ] ,
		[   a owl2spin:ObjectUnionOf_3CE ] ,
		# Complement of Class Expressions 
		[   a owl2spin:ObjectComplementOf ] ,
		# Enumeration of Individuals
		[   a owl2spin:ObjectOneOf_1 ] , 
		[   a owl2spin:ObjectOneOf_2 ] , 
		[   a owl2spin:ObjectOneOf_3 ] , 
		[   a owl2spin:ObjectOneOf_4 ] , 
		[   a owl2spin:ObjectOneOf_5 ] ,
		
		# Class Expressions - Object Property Restrictions
		# -----
		# Existential Quantification 
		[   a owl2spin:ObjectSomeValuesFrom ] ,
		# Universal Quantification 
		[   a owl2spin:ObjectAllValuesFrom ] ,
		# Individual Value Restriction 
		[   a owl2spin:ObjectHasValue ] ,
		# Self-Restriction 
		[   a owl2spin:ObjectHasSelf ] ,
		
		# Class Expressions - Object Property Cardinality Restrictions 
		# -----
		# Minimum Cardinality 
		[   a owl2spin:ObjectMinCardinality_Cardinality ] ,
		[   a owl2spin:ObjectMinCardinality_QualifiedCardinality ] ,
		# Maximum Cardinality
		[   a owl2spin:ObjectMaxCardinality_Cardinality ] ,
		[   a owl2spin:ObjectMaxCardinality_QualifiedCardinality ] ,
		# Exact Cardinality
		[   a owl2spin:ObjectExactCardinality_Cardinality ] ,
		[   a owl2spin:ObjectExactCardinality_QualifiedCardinality ] ,
		
		# Class Expressions - Data Property Restrictions 
		# -----
		# Existential Quantification 
		[   a owl2spin:DataSomeValuesFrom ] ,
		# Universal Quantification 
		[   a owl2spin:DataAllValuesFrom ] ,
		# Literal Value Restriction 
		[   a owl2spin:DataHasValue ] ,
		
		# Class Expressions - Data Property Cardinality Restrictions 
		# -----
		# Minimum Cardinality 
		[   a owl2spin:DataMinCardinality_Cardinality ] ,
		[   a owl2spin:DataMinCardinality_QualifiedCardinality ] ,
		# Maximum Cardinality
		[   a owl2spin:DataMaxCardinality_Cardinality ] ,
		[   a owl2spin:DataMaxCardinality_QualifiedCardinality ] ,
		# Exact Cardinality 
		[   a owl2spin:DataExactCardinality_Cardinality ] ,
		[   a owl2spin:DataExactCardinality_QualifiedCardinality ] ,
		
		# Axioms - Class Expression Axioms
		# -----
		# Disjoint Classes
		[   a owl2spin:DisjointClasses ] ,
		# Disjoint Union of Class Expressions
		[   a owl2spin:DisjointUnion_2CE_1 ] ,
		[   a owl2spin:DisjointUnion_2CE_2 ] ,
		[   a owl2spin:DisjointUnion_2CE_3 ] ,
		
		# Axioms - Object Property Axioms
		# -----
		# Object Subproperties 
#		[   a owl2spin:SubObjectPropertyOf ] ,
		# Object Property Chains 
#		[   a owl2spin:ObjectPropertyChain_2OPE ] ,
#		[   a owl2spin:ObjectPropertyChain_3OPE ] ,
		# Disjoint Object Properties
		[   a owl2spin:DisjointObjectProperties ] ,
		# Inverse Object Properties
#		[   a owl2spin:InverseObjectProperties ] ,
		# Object Property Domain
		[   a owl2spin:ObjectPropertyDomain ] ,
		# Object Property Range
		[   a owl2spin:ObjectPropertyRange ] ,
		# Functional Object Property
		[   a owl2spin:FunctionalObjectProperty ] ,
		# Inverse-Functional Object Property
		[   a owl2spin:InverseFunctionalObjectProperty ] ,
		# Reflexive Object Properties
#       [   a owl2spin:ReflexiveObjectProperties ] ,
		# Irreflexive Object Properties
        [   a owl2spin:IrreflexiveObjectProperties ] ,
        # Symmetric Object Properties
        [   a owl2spin:SymmetricObjectProperties ] ,
        # Asymmetric Object Properties
        [   a owl2spin:AsymmetricObjectProperties ] ,
        # Transitive Object Properties
        [   a owl2spin:TransitiveObjectProperties ] ,
		
		# Axioms - Data Property Axioms
		# -----
		# Disjoint Data Properties
		[   a owl2spin:DisjointDataProperties ] ,		
		# Data Property Domain
		[   a owl2spin:DataPropertyDomain ] ,
		# Data Property Range
		[   a owl2spin:DataPropertyRange ] ,
		# Functional Data Properties
		[   a owl2spin:FunctionalDataProperties ] ,
		
		# Axioms - Datatype Definitions 
		[   a owl2spin:DatatypeDefinition_Pattern ] ,
		
		# Axioms - Keys
		# -----
		[   a owl2spin:HasKey ] ,

		# Axioms - Assertions
		# -----
		# Negative Object Property Assertions 
		[   a owl2spin:NegativeObjectPropertyAssertion ] ,
		# Negative Data Property Assertions 
		[   a owl2spin:NegativeDataPropertyAssertion ] .
		
rdfs:Literal 
	spin:constraint 
	
		# Data Ranges - Set-Oriented Operations
		# -----
		# Intersection of Data Ranges
		[   a owl2spin:DataIntersectionOf_2DR ] ,
		# Union of Data Ranges 
		[   a owl2spin:DataUnionOf_2DR ] ,
		# Complement of Data Ranges
		[   a owl2spin:DataComplementOf ] .

# -----

# ---------------
# Data Ranges - Set-Oriented Operations - Intersection of Data Ranges 


owl2spin:DataIntersectionOf_2DR
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
#   spin:violationSource:
    spin:labelTemplate "OWL 2 - Data Ranges - Intersection of Data Ranges " ;
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	    
	    		?this rdf:type ?DT .
	    		
	    		?DT rdf:type rdfs:Datatype .
       			
#      			?DT owl:intersectionOf ( ?DR1 ?DR2 ) .
#      			-----         
	    		?DT owl:intersectionOf ?DRs .
	    		?DRs rdf:first ?DR1 .
	    		?DRs rdf:rest ?rest_1 .
	    		?rest_1 rdf:first ?DR2 .
	    		?rest_1 rdf:rest ?rest_2 .
	    		FILTER ( ?rest_2 = rdf:nil ) .

				FILTER NOT EXISTS { ?this rdf:type ?DR1 . ?this rdf:type ?DR2 . }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataIntersectionOf ( \", 
                    xsd:string( ?DR1 ), 
                    \" \", 
                    xsd:string( ?DR2 ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----
    
# ---------------
# Data Ranges - Set-Oriented Operations -  Union of Data Ranges 


owl2spin:DataUnionOf_2DR
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
#   spin:violationSource:
    spin:labelTemplate "OWL 2 - Data Ranges - Union of Data Ranges " ;
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	    
	    		?this rdf:type ?DT .
	    		
	    		?DT rdf:type rdfs:Datatype .
       			
#      			?DT owl:unionOf ( ?DR1 ?DR2 ) .
#      			-----         
	    		?DT owl:unionOf ?DRs .
	    		?DRs rdf:first ?DR1 .
	    		?DRs rdf:rest ?rest_1 .
	    		?rest_1 rdf:first ?DR2 .
	    		?rest_1 rdf:rest ?rest_2 .
	    		FILTER ( ?rest_2 = rdf:nil ) .

				FILTER NOT EXISTS { { ?this rdf:type ?DR1 } UNION { ?this rdf:type ?DR2 } }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataUnionOf ( \", 
                    xsd:string( ?DR1 ), 
                    \" \", 
                    xsd:string( ?DR2 ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----

# ---------------
# Class Expressions - Set-Oriented Operations - Intersection of Class Expressions


# 2 CE
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:intersectionOf ( ?CE1 ?CE2 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:intersectionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#		FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectIntersectionOf_2CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectIntersectionOf";
	rdfs:label "ObjectIntersectionOf";
	rdfs:comment "ObjectIntersectionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:intersectionOf ( ?CE1 ?CE2 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:intersectionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:intersectionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . }
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE1" ] ]
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE2" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectIntersectionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " )" ] ] ) ].

# 3 CE
# -----					
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:intersectionOf ( ?CE1 ?CE2 ?CE3 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:intersectionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    ?rest_2 rdf:first ?CE3 .
#	    ?rest_2 rdf:rest ?rest_3 .
#	    FILTER ( ?rest_3 = rdf:nil ) .
#
#		FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . ?this rdf:type ?CE3 . }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectIntersectionOf_3CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectIntersectionOf";
	rdfs:label "ObjectIntersectionOf";
	rdfs:comment "ObjectIntersectionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:intersectionOf ( ?CE1 ?CE2 ?CE3 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:intersectionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	?rest_2 rdf:first ?CE3 .
#	    	?rest_2 rdf:rest ?rest_3 .
#	    	FILTER ( ?rest_3 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:intersectionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE3" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_3" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_3" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { ?this rdf:type ?CE1 . ?this rdf:type ?CE2 . ?this rdf:type ?CE2 . }
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE1" ] ]
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE2" ] ] 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE3" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectIntersectionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE3" ] ;
					sp:arg7 " )" ] ] ) ].

# -----

# ---------------
# Class Expressions - Set-Oriented Operations - Union of Class Expressions


# 2 CE
# -----
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:unionOf ( ?CE1 ?CE2 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:unionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    FILTER ( ?rest_2 = rdf:nil ) .
#
#		FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectUnionOf_2CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectUnionOf";
	rdfs:label "ObjectUnionOf";
	rdfs:comment "ObjectUnionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:unionOf ( ?CE1 ?CE2 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:unionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	FILTER ( ?rest_2 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:unionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } }
			[   a sp:Filter ;
                sp:expression [
					a sp:notExists ;
                    sp:elements ( 
						[   a sp:Union ;
							sp:elements ( 
							( 
								[   sp:object [ sp:varName "CE1" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) 
							(
								[   sp:object [ sp:varName "CE2" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) ) ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectUnionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " )" ] ] ) ].
			
# 3 CE
# -----		
#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this rdf:type ?type .
#		?type sp:path ?C .
#
#       ?C rdf:type owl:Class ;
#       ?C owl:unionOf ( ?CE1 ?CE2 ?CE3 ) .
#       -----
#       ?C rdf:type owl:Class .          
#	    ?C owl:unionOf ?CEs .
#	    ?CEs rdf:first ?CE1 .
#	    ?CEs rdf:rest ?rest_1 .
#	    ?rest_1 rdf:first ?CE2 .
#	    ?rest_1 rdf:rest ?rest_2 .
#	    ?rest_2 rdf:first ?CE3 .
#	    ?rest_2 rdf:rest ?rest_3 .
#	    FILTER ( ?rest_3 = rdf:nil ) .
#
#		FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } UNION { ?this rdf:type ?CE3 . } }
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectUnionOf_3CE
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectUnionOf";
	rdfs:label "ObjectUnionOf";
	rdfs:comment "ObjectUnionOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this rdf:type ?type .
#			?type sp:path ?C .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "C" ] ] 

#           ?C rdf:type owl:Class ;
#           ?C owl:unionOf ( ?CE1 ?CE2 ?CE3 ) .
#       	-----
#           ?C rdf:type owl:Class .          
#	    	?C owl:unionOf ?CEs .
#	    	?CEs rdf:first ?CE1 .
#	    	?CEs rdf:rest ?rest_1 .
#	    	?rest_1 rdf:first ?CE2 .
#	    	?rest_1 rdf:rest ?rest_2 .
#	    	?rest_2 rdf:first ?CE3 .
#	    	?rest_2 rdf:rest ?rest_3 .
#	    	FILTER ( ?rest_3 = rdf:nil ) .	
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:unionOf ;
				sp:object [ sp:varName "CEs" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE1" ] ]
			[   sp:subject [ sp:varName "CEs" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "CE3" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_3" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_3" ];
					sp:arg2 rdf:nil ] ]	

#			FILTER NOT EXISTS { { ?this rdf:type ?CE1 . } UNION { ?this rdf:type ?CE2 . } UNION { ?this rdf:type ?CE3 . } }
			[   a sp:Filter ;
                sp:expression [
					a sp:notExists ;
                    sp:elements ( 
						[   a sp:Union ;
							sp:elements ( 
							( 
								[   sp:object [ sp:varName "CE1" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) 
							(
								[   sp:object [ sp:varName "CE2" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] )
							(
								[   sp:object [ sp:varName "CE3" ] ;
                                    sp:predicate rdf:type ;
                                    sp:subject [ sp:varName "this" ] ] ) ) ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectUnionOf ( " ;
					sp:arg2 [ sp:varName "CE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE3" ] ;
					sp:arg7 " )" ] ] ) ].

# -----

# ---------------
# Class Expressions - Set-Oriented Operations - Complement of Class Expressions


#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
#
#	    ObjectComplementOf ( CE )
#	    -----				
#       ?class rdf:type owl:Class .
#       ?class owl:complementOf ?CE .
#
#       FILTER EXISTS { ?this rdf:type ?CE . } 
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectComplementOf
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectComplementOf";
	rdfs:label "ObjectComplementOf";
	rdfs:comment "ObjectComplementOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 

#	    	ObjectComplementOf ( CE )
#	    	-----				
#           ?class rdf:type owl:Class .
#           ?class owl:complementOf ?CE .
			
            [   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Class ]
            [   sp:subject [ sp:varName "class" ];
				sp:predicate owl:complementOf;
				sp:object [ sp:varName "CE" ] ]				
				
#           FILTER EXISTS { ?this rdf:type ?CE . }  
#           -----			
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectComplementOf ( " ;
					sp:arg2 [ sp:varName "CE" ] ;
					sp:arg3 " )" ] ] ) ].

# -----	

# ---------------
# Class Expressions - Set-Oriented Operations - Enumeration of Individuals


# 1 Individual
# -----
owl2spin:ObjectOneOf_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R1" ];
					sp:arg2 rdf:nil ] ]
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           FILTER ( ?isElementInList_I1 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " )" ] ] ) ].

# 2 Individuals
# -----
owl2spin:ObjectOneOf_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R2" ];
					sp:arg2 rdf:nil ] ]
#			BIND( ( IF( BOUND( ?I2_tmp ), ?I2_tmp, ""^^xsd:string ) ) AS ?I2 ) .
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]
#           BIND( ( IF( BOUND( ?I2_tmp ) && ?I2_tmp = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           FILTER ( ?isElementInList_I1 = "false"^^xsd:boolean && ?isElementInList_I2 = "false"^^xsd:boolean  ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ;
					sp:arg2 [
						a sp:eq ;
						sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " )" ] ] ) ].

# 3 Individuals
# -----
owl2spin:ObjectOneOf_3
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I3_tmp" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R3" ];
					sp:arg2 rdf:nil ] ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I3_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I3_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I3" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I3"^^xsd:boolean ] ]
				
#           FILTER ( 
#				?isElementInList_I1 = "false"^^xsd:boolean && 
#				?isElementInList_I2 = "false"^^xsd:boolean && 
#				?isElementInList_I3 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:and ;
                    sp:arg1 [ 
						a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [ 
					    a sp:eq ;
                        sp:arg1 [ sp:varName "isElementInList_I3"^^xsd:boolean ] ;
                        sp:arg2 "false"^^xsd:boolean ]
				] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 " | I3: " ;
#					sp:arg10 [ sp:varName "I3" ] ;
#					sp:arg11 " | isElementInList_I3: " ;
#					sp:arg12 [ sp:varName "isElementInList_I3" ] ;
#					sp:arg13 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "I3" ] ;
					sp:arg7 " )" ] ] ) ].
					
# 4 Individuals
# -----
owl2spin:ObjectOneOf_4
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I3_tmp" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I3_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I3_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I3" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I3"^^xsd:boolean ] ]
				
#           4. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I4_tmp" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R4" ];
					sp:arg2 rdf:nil ] ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I4_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I4_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I4" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I4"^^xsd:boolean ] ]
				
#           FILTER ( 
#				?isElementInList_I1 = "false"^^xsd:boolean && 
#				?isElementInList_I2 = "false"^^xsd:boolean && 
#				?isElementInList_I3 = "false"^^xsd:boolean && 
#				?isElementInList_I4 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:and ;
                    sp:arg1 [ 
						a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I4"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
				] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 " | I3: " ;
#					sp:arg10 [ sp:varName "I3" ] ;
#					sp:arg11 " | isElementInList_I3: " ;
#					sp:arg12 [ sp:varName "isElementInList_I3" ] ;
#					sp:arg13 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "I3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "I4" ] ;
					sp:arg9 " )" ] ] ) ].
					
# 5 Individuals
# -----
owl2spin:ObjectOneOf_5
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectOneOf" ;
	rdfs:label "ObjectOneOf" ;
	rdfs:comment "ObjectOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?C
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "C" ] ]

#		    ?C owl:equivalentClass ?EC .
#           ?EC rdf:type owl:Class .
#           -----
            [   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Class ]

#           ?EC owl:oneOf ?list
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "I1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND( ( IF( ?I1 = ?this, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isElementInList_I1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "I1"^^xsd:string ] ;
						sp:arg2 [ sp:varName "this"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List 
#           -----         
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I2_tmp" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I2_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I2_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I2" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I2_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I3_tmp" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I3_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I3_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I3" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I3_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I3"^^xsd:boolean ] ]
				
#           4. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I4_tmp" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I4_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I4_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I4" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I4_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I4"^^xsd:boolean ] ]
				
#           5. element of rdf:List 
#           -----         			
			[   sp:subject [ sp:varName "R4" ] ;
				sp:predicate rdf:first ;
				sp:object  [ sp:varName "I5_tmp" ] ]
			[   sp:subject [ sp:varName "R4" ] ;
				sp:predicate rdf:rest ;
				sp:object [ sp:varName "R5" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R5" ];
					sp:arg2 rdf:nil ] ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "I5_tmp" ] ] ;
                        sp:arg2 [ sp:varName "I5_tmp" ] ;
                        sp:arg3 ""^^xsd:string ] ;
                    sp:variable [ sp:varName "I5" ] ]	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:bound ;
                            sp:arg1 [ sp:varName "I5_tmp"^^xsd:string ] ] ;
                        sp:arg2 [
							a sp:eq ;
                            sp:arg1 [ sp:varName "I5_tmp"^^xsd:string ] ;
                            sp:arg2 [ sp:varName "this"^^xsd:string ] ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isElementInList_I5"^^xsd:boolean ] ]
				
#           FILTER ( 
#				?isElementInList_I1 = "false"^^xsd:boolean && 
#				?isElementInList_I2 = "false"^^xsd:boolean && 
#				?isElementInList_I3 = "false"^^xsd:boolean && 
#				?isElementInList_I4 = "false"^^xsd:boolean && 
#				?isElementInList_I5 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
				    a sp:and ;
                    sp:arg1 [ 
						a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:eq ;
                            sp:arg1 [ sp:varName "isElementInList_I2"^^xsd:boolean ] ;
                            sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [ 
					    a sp:and ;
                        sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isElementInList_I3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
						    a sp:and ;
							sp:arg1 [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isElementInList_I4"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ;
							sp:arg2 [
								a sp:eq ;
								sp:arg1 [ sp:varName "isElementInList_I5"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ] ;
					] ;
				] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "I1: " ;
#					sp:arg2 [ sp:varName "I1" ] ;
#					sp:arg3 " | isElementInList_I1: " ;
#					sp:arg4 [ sp:varName "isElementInList_I1" ] ;
#					sp:arg5 " | I2: " ;
#					sp:arg6 [ sp:varName "I2" ] ;
#					sp:arg7 " | isElementInList_I2: " ;
#					sp:arg8 [ sp:varName "isElementInList_I2" ] ;
#					sp:arg9 " | I3: " ;
#					sp:arg10 [ sp:varName "I3" ] ;
#					sp:arg11 " | isElementInList_I3: " ;
#					sp:arg12 [ sp:varName "isElementInList_I3" ] ;
#					sp:arg13 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectOneOf ( " ;
					sp:arg2 [ sp:varName "I1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "I3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "I4" ] ;
					sp:arg9 " " ;
					sp:arg10 [ sp:varName "I5" ] ;
					sp:arg11 " )" ] ] ) ].

# -----

# ---------------
# Data Ranges - Set-Oriented Operations - Complement of Data Ranges


#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
#
#	    DataComplementOf ( DR )
#	    -----				
#       ?class rdf:type rdfs:Datatype .
#       ?class owl:complementOf ?DR .
#
#       FILTER EXISTS { ?this rdf:type ?DR . } 
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:DataComplementOf
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataComplementOf";
	rdfs:label "DataComplementOf";
	rdfs:comment "DataComplementOf";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 

#	    	ObjectComplementOf ( DR )
#	    	-----				
#           ?class rdf:type rdfs:Datatype .
#           ?class owl:complementOf ?DR .
			
            [   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object rdfs:Datatype ]
            [   sp:subject [ sp:varName "class" ];
				sp:predicate owl:complementOf;
				sp:object [ sp:varName "DR" ] ]				
				
#           FILTER EXISTS { ?this rdf:type ?DR . }  
#           -----			
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "DR" ] ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataComplementOf ( " ;
					sp:arg2 [ sp:varName "DR" ] ;
					sp:arg3 " )" ] ] ) ].

# -----	

# ---------------
# Data Ranges - Set-Oriented Operations -  Enumeration of Literals 


# 1 literal
# -----
owl2spin:DataOneOf_1L
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?literal ) . 
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "literal" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R1" ];
					sp:arg2 rdf:nil ] ]
#           BIND( ( IF( ?L1 = ?L, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1" ] ;
						sp:arg2 [ sp:varName "literal" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           FILTER ( ?isLInDT_L1 = "false"^^xsd:boolean ) .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:eq ;
					sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
					sp:arg2 "false"^^xsd:boolean ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " )" ] ] ) ] .

# 2 literals
# -----
owl2spin:DataOneOf_2L
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R2" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           FILTER ( ?isLInDT_L1 = "false"^^xsd:boolean && ?isLInDT_L2 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ;
					sp:arg2 [
						a sp:eq ;
						sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " )" ] ] ) ].

# 3 literals
# -----
owl2spin:DataOneOf_3L
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L3" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R3" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L3 ) ) AS ?L3_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L3_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L3" ] ] ] 
#           BIND( ( IF( ?L3_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L3 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L3_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L3"^^xsd:boolean ] ] 
				
#           FILTER ( 
#           	?isLInDT_L1 = "false"^^xsd:boolean && 
#           	?isLInDT_L2 = "false"^^xsd:boolean && 
#               ?isLInDT_L3 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [
						a sp:eq ;
						sp:arg1 [ sp:varName "isLInDT_L3"^^xsd:boolean ] ;
						sp:arg2 "false"^^xsd:boolean ] ] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 " | L3: " ;
#					sp:arg16 [ sp:varName "L3" ] ;
#					sp:arg17 " | isLInDT_L3: " ;
#					sp:arg18 [ sp:varName "isLInDT_L3" ] ;
#					sp:arg19 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "L3" ] ;
					sp:arg7 " )" ] ] ) ].

# 4 literals
# -----
owl2spin:DataOneOf_4L
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L3" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
#           BIND ( ( str ( ?L3 ) ) AS ?L3_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L3_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L3" ] ] ] 
#           BIND( ( IF( ?L3_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L3 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L3_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L3"^^xsd:boolean ] ] 
				
#           4. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L4" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R4" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L4 ) ) AS ?L4_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L4_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L4" ] ] ] 
#           BIND( ( IF( ?L4_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L4 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L4_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L4"^^xsd:boolean ] ] 
				
#           FILTER ( 
#           	?isLInDT_L1 = "false"^^xsd:boolean && 
#           	?isLInDT_L2 = "false"^^xsd:boolean && 
#           	?isLInDT_L3 = "false"^^xsd:boolean && 
#               ?isLInDT_L4 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L4"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
						] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 " | L3: " ;
#					sp:arg16 [ sp:varName "L3" ] ;
#					sp:arg17 " | isLInDT_L3: " ;
#					sp:arg18 [ sp:varName "isLInDT_L3" ] ;
#					sp:arg19 " | L4: " ;
#					sp:arg20 [ sp:varName "L4" ] ;
#					sp:arg21 " | isLInDT_L4: " ;
#					sp:arg22 [ sp:varName "isLInDT_L4" ] ;
#					sp:arg23 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "L3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "L4" ] ;
					sp:arg9 " )" ] ] ) ].

# 5 literals
# -----
owl2spin:DataOneOf_5L
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataOneOf" ;
	rdfs:label "DataOneOf" ;
	rdfs:comment "DataOneOf" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?this ?DPE ?L ;
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . [ --> datatype xsd:string ]
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype ;
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]

#           ?DT owl:oneOf ?list .
#           1. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:oneOf ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L1" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
#           BIND ( ( str ( ?L1 ) ) AS ?L1_str ) . [ --> datatype xsd:string ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L1_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L1" ] ] ] 
#           BIND( ( IF( ?L1_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L1 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L1_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L1"^^xsd:boolean ] ] 
				
#           2. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L2" ] ]
			[   sp:subject [ sp:varName "R1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R2" ] ]	
#           BIND ( ( str ( ?L2 ) ) AS ?L2_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L2_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L2" ] ] ] 
#           BIND( ( IF( ?L2_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L2 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L2_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L2"^^xsd:boolean ] ] 
				
#           3. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L3" ] ]
			[   sp:subject [ sp:varName "R2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R3" ] ]	
#           BIND ( ( str ( ?L3 ) ) AS ?L3_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L3_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L3" ] ] ] 
#           BIND( ( IF( ?L3_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L3 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L3_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L3"^^xsd:boolean ] ] 
				
#           4. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L4" ] ]
			[   sp:subject [ sp:varName "R3" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R4" ] ]	
#           BIND ( ( str ( ?L4 ) ) AS ?L4_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L4_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L4" ] ] ] 
#           BIND( ( IF( ?L4_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L4 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L4_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L4"^^xsd:boolean ] ] 
				
#           5. element of rdf:List: 
#           -----
			[   sp:subject [ sp:varName "R4" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "L5" ] ]
			[   sp:subject [ sp:varName "R4" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R5" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R5" ];
					sp:arg2 rdf:nil ] ]
#           BIND ( ( str ( ?L5 ) ) AS ?L5_str ) . 
			[   a sp:Bind;
				sp:variable [ sp:varName "L5_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L5" ] ] ] 
#           BIND( ( IF( ?L5_str = ?L_str, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?isLInDT_L5 ) .	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "L5_str" ] ;
						sp:arg2 [ sp:varName "L_str" ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "isLInDT_L5"^^xsd:boolean ] ] 
				
#           FILTER ( 
#           	?isLInDT_L1 = "false"^^xsd:boolean && 
#           	?isLInDT_L2 = "false"^^xsd:boolean && 
#           	?isLInDT_L3 = "false"^^xsd:boolean && 
#           	?isLInDT_L4 = "false"^^xsd:boolean && 
#               ?isLInDT_L5 = "false"^^xsd:boolean ) .
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:and ;
					sp:arg1 [ 
						a sp:and ;
						sp:arg1 [ 
							a sp:and ;
							sp:arg1 [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "isLInDT_L1"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ;
							sp:arg2 [
								a sp:eq ;
								sp:arg1 [ sp:varName "isLInDT_L2"^^xsd:boolean ] ;
								sp:arg2 "false"^^xsd:boolean ] ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L3"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
					sp:arg2 [
						a sp:and ;
						sp:arg1 [ 
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L4"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ;
						sp:arg2 [
							a sp:eq ;
							sp:arg1 [ sp:varName "isLInDT_L5"^^xsd:boolean ] ;
							sp:arg2 "false"^^xsd:boolean ] ] ;
						] ] 

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "DT: " ;
#					sp:arg2 [ sp:varName "DT" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | L: " ;
#					sp:arg6 [ sp:varName "L" ] ;
#					sp:arg7 " | L1: " ;
#					sp:arg8 [ sp:varName "L1" ] ;
#					sp:arg9 " | isLInDT_L1: " ;
#					sp:arg10 [ sp:varName "isLInDT_L1" ] ;
#					sp:arg11 " | L2: " ;
#					sp:arg12 [ sp:varName "L2" ] ;
#					sp:arg13 " | isLInDT_L2: " ;
#					sp:arg14 [ sp:varName "isLInDT_L2" ] ;
#					sp:arg15 " | L3: " ;
#					sp:arg16 [ sp:varName "L3" ] ;
#					sp:arg17 " | isLInDT_L3: " ;
#					sp:arg18 [ sp:varName "isLInDT_L3" ] ;
#					sp:arg19 " | L4: " ;
#					sp:arg20 [ sp:varName "L4" ] ;
#					sp:arg21 " | isLInDT_L4: " ;
#					sp:arg22 [ sp:varName "isLInDT_L4" ] ;
#					sp:arg23 " | L5: " ;
#					sp:arg24 [ sp:varName "L5" ] ;
#					sp:arg25 " | isLInDT_L5: " ;
#					sp:arg26 [ sp:varName "isLInDT_L5" ] ;
#					sp:arg27 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataOneOf ( " ;
					sp:arg2 [ sp:varName "L1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "L3" ] ;
					sp:arg7 " " ;
					sp:arg8 [ sp:varName "L4" ] ;
					sp:arg9 " " ;
					sp:arg10 [ sp:varName "L5" ] ;
					sp:arg11 " )" ] ] ) ].

# -----

# ---------------
# Class Expressions - Object Property Cardinality Restrictions - Minimum Cardinality


owl2spin:ObjectMinCardinality_Cardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Object Property Cardinality Restrictions - Minimum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#        	    ?this ?OPE ?o .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?OPE ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?this rdf:type ?CE .
 
#	            ObjectMinCardinality ( Minimum OPE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:minCardinality ?Minimum .
		        ?CE owl:onProperty ?OPE .
		        
#		        ?cardinality < ?MinimumCardinality
#               -----
		        BIND ( owl2spin:cardinalityOPE( ?this, ?OPE ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Minimum ), xsd:nonNegativeInteger ) AS ?MinimumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality < ?MinimumCardinality ) .
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectMinCardinality ( \", 
                    xsd:string( ?Minimum ), 
                    \" \", 
                    xsd:string( ?OPE ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?OPE ), 
                    \"' to at least \", 
                    xsd:string( ?MinimumCardinality ),
                    \" different individual(s), but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:ObjectMinCardinality_QualifiedCardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Object Property Cardinality Restrictions - Minimum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?o .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?this rdf:type ?CE .
 
#	            ObjectMinCardinality ( Minimum OPE CE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:minQualifiedCardinality ?Minimum .
		        ?CE owl:onProperty ?OPE .
		        ?CE owl:onClass ?CE_ .
		        
#		        ?cardinality < ?Minimum
#               -----
		        BIND ( owl2spin:qualifiedCardinalityOPE( ?this, ?OPE, ?CE_ ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Minimum ), xsd:nonNegativeInteger ) AS ?MinimumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality < ?MinimumCardinality ) .		    
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectMinCardinality ( \", 
                    xsd:string( ?Minimum ), 
                    \" \", 
                    xsd:string( ?OPE ), 
                    \" \", 
                    xsd:string( ?CE_ ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?OPE ), 
                    \"' to at least \", 
                    xsd:string( ?Minimum ),
                    \" different individual(s) that are instances of '\", 
                    xsd:string( ?CE_ ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    ObjectMinCardinality ( Minimum OPE CE )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#		?class owl:onProperty ?OPE .
#       OPTIONAL { ?class owl:onClass ?CE_tmp } .
#		BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
#
#	    qualifiedCardinality < Minimum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality < ?Minimum ) .
#
#       OPE is object property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectMinCardinality_old
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectMinCardinality";
	rdfs:label "ObjectMinCardinality";
	rdfs:comment "ObjectMinCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	ObjectMinCardinality ( Minimum OPE CE )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#			?class owl:onProperty ?OPE .
#           OPTIONAL { ?class owl:onClass ?CE_tmp } .
#			BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minCardinality;
				        sp:object [ sp:varName "Minimum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minQualifiedCardinality;
				        sp:object [ sp:varName "Minimum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "OPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "CE_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "CE_tmp" ] ] ;
                        sp:arg2 [ sp:varName "CE_tmp" ] ;
                        sp:arg3 owl:Thing ] ;
                    sp:variable [ sp:varName "CE" ] ]
				
#	    	qualifiedCardinality < Minimum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#			FILTER ( qualifiedCardinality < ?Minimum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityObjectProperties;
					sp:arg1 [ sp:varName "OPE" ] ;
					sp:arg2 [ sp:varName "CE" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Minimum" ] ] ]
					
#           OPE is object property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectMinCardinality ( " ;
					sp:arg2 [ sp:varName "Minimum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE" ] ;
					sp:arg7 " )" ] ] ) ].

# -----	

# ---------------
# Class Expressions - Object Property Cardinality Restrictions - Maximum Cardinality


owl2spin:ObjectMaxCardinality_Cardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Object Property Cardinality Restrictions - Maximum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#        	    ?this ?OPE ?o .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?OPE ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?this rdf:type ?CE .
 
#	            ObjectMaxCardinality ( Maximum OPE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:maxCardinality ?Maximum .
		        ?CE owl:onProperty ?OPE .
		        
#		        ?cardinality > ?MaximumCardinality
#               -----
		        BIND ( owl2spin:cardinalityOPE( ?this, ?OPE ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Maximum ), xsd:nonNegativeInteger ) AS ?MaximumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality > ?MaximumCardinality ) .
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectMaxCardinality ( \", 
                    xsd:string( ?Maximum ), 
                    \" \", 
                    xsd:string( ?OPE ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?OPE ), 
                    \"' to at most \", 
                    xsd:string( ?MaximumCardinality ),
                    \" different individual(s), but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:ObjectMaxCardinality_QualifiedCardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Object Property Cardinality Restrictions - Maximum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?o .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?this rdf:type ?CE .
 
#	            ObjectMaxCardinality ( Maximum OPE CE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:maxQualifiedCardinality ?Maximum .
		        ?CE owl:onProperty ?OPE .
		        ?CE owl:onClass ?CE_ .
		        
#		        ?cardinality > ?Maximum
#               -----
		        BIND ( owl2spin:qualifiedCardinalityOPE( ?this, ?OPE, ?CE_ ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Maximum ), xsd:nonNegativeInteger ) AS ?MaximumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality > ?MaximumCardinality ) .		    
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectMaxCardinality ( \", 
                    xsd:string( ?Maximum ), 
                    \" \", 
                    xsd:string( ?OPE ), 
                    \" \", 
                    xsd:string( ?CE_ ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?OPE ), 
                    \"' to at most \", 
                    xsd:string( ?Maximum ),
                    \" different individual(s) that are instances of '\", 
                    xsd:string( ?CE_ ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    ObjectMaxCardinality ( Maximum OPE CE )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#		?class owl:onProperty ?OPE .
#       OPTIONAL { ?class owl:onClass ?CE_tmp } .
#		BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
#
#	    qualifiedCardinality > Maximum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality > ?Maximum ) .
#
#       OPE is object property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectMaxCardinality_old
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectMaxCardinality";
	rdfs:label "ObjectMaxCardinality";
	rdfs:comment "ObjectMaxCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	ObjectMaxCardinality ( Maximum OPE CE )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#			?class owl:onProperty ?OPE .
#           OPTIONAL { ?class owl:onClass ?CE_tmp } .
#			BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxCardinality;
				        sp:object [ sp:varName "Maximum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxQualifiedCardinality;
				        sp:object [ sp:varName "Maximum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "OPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "CE_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "CE_tmp" ] ] ;
                        sp:arg2 [ sp:varName "CE_tmp" ] ;
                        sp:arg3 owl:Thing ] ;
                    sp:variable [ sp:varName "CE" ] ]
				
#	    	qualifiedCardinality > Maximum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#			FILTER ( qualifiedCardinality > ?Maximum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityObjectProperties;
					sp:arg1 [ sp:varName "OPE" ] ;
					sp:arg2 [ sp:varName "CE" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Maximum" ] ] ]
					
#           OPE is object property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectMaxCardinality ( " ;
					sp:arg2 [ sp:varName "Maximum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE" ] ;
					sp:arg7 " )" ] ] ) ].
					
# -----
		
# ---------------
# Class Expressions - Object Property Cardinality Restrictions - Exact Cardinality
		

owl2spin:ObjectExactCardinality_Cardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Object Property Cardinality Restrictions - Exact Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#        	    ?this ?OPE ?o .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?OPE ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?this rdf:type ?CE .
 
#	            ObjectExactCardinality ( Exact OPE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:cardinality ?Exact .
		        ?CE owl:onProperty ?OPE .
		        
#		        ?cardinality != ?ExactCardinality
#               -----
		        BIND ( owl2spin:cardinalityOPE( ?this, ?OPE ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Exact ), xsd:nonNegativeInteger ) AS ?ExactCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality != ?ExactCardinality ) .
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectExactCardinality ( \", 
                    xsd:string( ?Exact ), 
                    \" \", 
                    xsd:string( ?OPE ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?OPE ), 
                    \"' to exactly \", 
                    xsd:string( ?ExactCardinality ),
                    \" different individual(s), but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:ObjectExactCardinality_QualifiedCardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Object Property Cardinality Restrictions - Exact Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?o .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?this rdf:type ?CE .
 
#	            ObjectExactCardinality ( Exact OPE CE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:qualifiedCardinality ?Exact .
		        ?CE owl:onProperty ?OPE .
		        ?CE owl:onClass ?CE_ .
		        
#		        ?cardinality != ?Exact
#               -----
		        BIND ( owl2spin:qualifiedCardinalityOPE( ?this, ?OPE, ?CE_ ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Exact ), xsd:nonNegativeInteger ) AS ?ExactCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality != ?ExactCardinality ) .		    
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectExactCardinality ( \", 
                    xsd:string( ?Exact ), 
                    \" \", 
                    xsd:string( ?OPE ), 
                    \" \", 
                    xsd:string( ?CE_ ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?OPE ), 
                    \"' to exactly \", 
                    xsd:string( ?Exact ),
                    \" different individual(s) that are instances of '\", 
                    xsd:string( ?CE_ ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" individual(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    ObjectExactCardinality ( Exact OPE CE )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#		?class owl:onProperty ?OPE .
#       OPTIONAL { ?class owl:onClass ?CE_tmp } .
#		BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
#
#	    qualifiedCardinality != Exact
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality != ?Exact ) .
#
#       OPE is object property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectExactCardinality_old
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "ObjectExactCardinality";
	rdfs:label "ObjectExactCardinality";
	rdfs:comment "ObjectExactCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	ObjectMinCardinality ( Exact OPE CE )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#			?class owl:onProperty ?OPE .
#           OPTIONAL { ?class owl:onClass ?CE_tmp } .
#			BIND( ( IF( BOUND( ?CE_tmp ), ?CE_tmp, owl:Thing ) ) AS ?CE ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:cardinality;
				        sp:object [ sp:varName "Exact" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:qualifiedCardinality;
				        sp:object [ sp:varName "Exact" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "OPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "CE_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "CE_tmp" ] ] ;
                        sp:arg2 [ sp:varName "CE_tmp" ] ;
                        sp:arg3 owl:Thing ] ;
                    sp:variable [ sp:varName "CE" ] ]
				
#	    	qualifiedCardinality != Exact
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#			FILTER ( qualifiedCardinality != ?Exact ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityObjectProperties;
					sp:arg1 [ sp:varName "OPE" ] ;
					sp:arg2 [ sp:varName "CE" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Exact" ] ] ]
					
#           OPE is object property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
					
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectExactCardinality ( " ;
					sp:arg2 [ sp:varName "Exact" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "CE" ] ;
					sp:arg7 " )" ] ] ) ].
	
# -----

# ---------------
# Class Expressions - Data Property Cardinality Restrictions - Minimum Cardinality


owl2spin:DataMinCardinality_Cardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Data Property Cardinality Restrictions - Minimum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?l .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                ?this rdf:type ?CE .
 
#	            DataMinCardinality ( Minimum DPE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:minCardinality ?Minimum .
		        ?CE owl:onProperty ?DPE .
		        
#		        ?cardinality < ?MinimumCardinality
#               -----
		        BIND ( owl2spin:cardinalityDPE( ?this, ?DPE ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Minimum ), xsd:nonNegativeInteger ) AS ?MinimumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality < ?MinimumCardinality ) .
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataMinCardinality ( \", 
                    xsd:string( ?Minimum ), 
                    \" \", 
                    xsd:string( ?DPE ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' to at least \", 
                    xsd:string( ?MinimumCardinality ),
                    \" different literal(s), but is connected to \",
                    xsd:string( ?cardinality ),
                    \" literal(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:DataMinCardinality_QualifiedCardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Data Property Cardinality Restrictions - Minimum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?l .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                ?this rdf:type ?CE .
 
#	            DataMinCardinality ( Minimum DPE DR )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:minQualifiedCardinality ?Minimum .
		        ?CE owl:onProperty ?DPE .
		        ?CE owl:onClass ?DR .
		        
#		        ?cardinality < ?Minimum
#               -----
		        BIND ( owl2spin:qualifiedCardinalityDPE( ?this, ?DPE, ?DR ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Minimum ), xsd:nonNegativeInteger ) AS ?MinimumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality < ?MinimumCardinality ) .		    
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataMinCardinality ( \", 
                    xsd:string( ?Minimum ), 
                    \" \", 
                    xsd:string( ?DPE ), 
                    \" \", 
                    xsd:string( ?DR ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' to at least \", 
                    xsd:string( ?Minimum ),
                    \" different literal(s) in '\", 
                    xsd:string( ?DR ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" literal(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    DataMinCardinality ( Minimum DPE DR )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#		?class owl:onProperty ?DPE .
#       OPTIONAL { ?class owl:onClass ?DR_tmp } .
#	    BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) 
#
#	    qualifiedCardinality < Minimum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality < ?Minimum ) .
#
#       DPE is data property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:DataMinCardinality_old
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataMinCardinality";
	rdfs:label "DataMinCardinality";
	rdfs:comment "DataMinCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	DataMinCardinality ( Minimum DPE DR )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:minCardinality ?Minimum } UNION { ?class owl:minQualifiedCardinality ?Minimum } .
#			?class owl:onProperty ?DPE .
#           OPTIONAL { ?class owl:onClass ?DR_tmp } .
#			BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minCardinality;
				        sp:object [ sp:varName "Minimum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:minQualifiedCardinality;
				        sp:object [ sp:varName "Minimum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "DPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "DR_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "DR_tmp" ] ] ;
                        sp:arg2 [ sp:varName "DR_tmp" ] ;
                        sp:arg3 rdfs:Literal ] ;
                    sp:variable [ sp:varName "DR" ] ]	
				
#	    	qualifiedCardinality < Minimum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( DPE, DR ) ) AS ?qualifiedCardinality ) . 
#			FILTER ( qualifiedCardinality < ?Minimum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityDataProperties;
					sp:arg1 [ sp:varName "DPE" ] ;
					sp:arg2 [ sp:varName "DR" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Minimum" ] ] ]
					
#           DPE is data property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
							
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataMinCardinality ( " ;
					sp:arg2 [ sp:varName "Minimum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "DR" ] ;
					sp:arg7 " )" ] ] ) ].

# -----	

# ---------------
# Class Expressions - Data Property Cardinality Restrictions - Maximum Cardinality


owl2spin:DataMaxCardinality_Cardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Data Property Cardinality Restrictions - Maximum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?l .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                ?this rdf:type ?CE .
 
#	            DataMaxCardinality ( Maximum DPE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:maxCardinality ?Maximum .
		        ?CE owl:onProperty ?DPE .
		        
#		        ?cardinality > ?MaximumCardinality
#               -----
		        BIND ( owl2spin:cardinalityDPE( ?this, ?DPE ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Maximum ), xsd:nonNegativeInteger ) AS ?MaximumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality > ?MaximumCardinality ) .
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataMaxCardinality ( \", 
                    xsd:string( ?Maximum ), 
                    \" \", 
                    xsd:string( ?DPE ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' to at most \", 
                    xsd:string( ?MaximumCardinality ),
                    \" different literal(s), but is connected to \",
                    xsd:string( ?cardinality ),
                    \" literal(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:DataMaxCardinality_QualifiedCardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Data Property Cardinality Restrictions - Maximum Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?l .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                ?this rdf:type ?CE .
 
#	            DataMaxCardinality ( Maximum DPE DR )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:maxQualifiedCardinality ?Maximum .
		        ?CE owl:onProperty ?DPE .
		        ?CE owl:onClass ?DR .
		        
#		        ?cardinality > ?Maximum
#               -----
		        BIND ( owl2spin:qualifiedCardinalityDPE( ?this, ?DPE, ?DR ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Maximum ), xsd:nonNegativeInteger ) AS ?MaximumCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality > ?MaximumCardinality ) .		    
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataMaxCardinality ( \", 
                    xsd:string( ?Maximum ), 
                    \" \", 
                    xsd:string( ?DPE ), 
                    \" \", 
                    xsd:string( ?DR ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' to at most \", 
                    xsd:string( ?Maximum ),
                    \" different literal(s) in '\", 
                    xsd:string( ?DR ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" literal(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    DataMaxCardinality ( Maximum DPE DR )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#		?class owl:onProperty ?DPE .
#       OPTIONAL { ?class owl:onClass ?DR_tmp } .
#	    BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) 
#
#	    qualifiedCardinality > Maximum
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality > ?Maximum ) .
#
#       DPE is data property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:DataMaxCardinality_old
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataMaxCardinality";
	rdfs:label "DataMaxCardinality";
	rdfs:comment "DataMaxCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	DataMinCardinality ( Maximum DPE DR )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:maxCardinality ?Maximum } UNION { ?class owl:maxQualifiedCardinality ?Maximum } .
#			?class owl:onProperty ?DPE .
#           OPTIONAL { ?class owl:onClass ?DR_tmp } .
#			BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxCardinality;
				        sp:object [ sp:varName "Maximum" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:maxQualifiedCardinality;
				        sp:object [ sp:varName "Maximum" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "DPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "DR_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "DR_tmp" ] ] ;
                        sp:arg2 [ sp:varName "DR_tmp" ] ;
                        sp:arg3 rdfs:Literal ] ;
                    sp:variable [ sp:varName "DR" ] ]	
				
#	    	qualifiedCardinality > Maximum
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( DPE, DR ) ) AS ?qualifiedCardinality ) . 
#			FILTER ( qualifiedCardinality > ?Maximum ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityDataProperties;
					sp:arg1 [ sp:varName "DPE" ] ;
					sp:arg2 [ sp:varName "DR" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Maximum" ] ] ]
					
#           DPE is data property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
							
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataMaxCardinality ( " ;
					sp:arg2 [ sp:varName "Maximum" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "DR" ] ;
					sp:arg7 " )" ] ] ) ].

# -----	

# ---------------
# Class Expressions - Data Property Cardinality Restrictions - Exact Cardinality

	
owl2spin:DataExactCardinality_Cardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Data Property Cardinality Restrictions - Exact Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?l .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                ?this rdf:type ?CE .
 
#	            DataExactCardinality ( Exact DPE )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:cardinality ?Exact .
		        ?CE owl:onProperty ?DPE .
		        
#		        ?cardinality != ?ExactCardinality
#               -----
		        BIND ( owl2spin:cardinalityDPE( ?this, ?DPE ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Exact ), xsd:nonNegativeInteger ) AS ?ExactCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality != ?ExactCardinality ) .
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataExactCardinality ( \", 
                    xsd:string( ?Exact ), 
                    \" \", 
                    xsd:string( ?DPE ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' to exactly \", 
                    xsd:string( ?ExactCardinality ),
                    \" different literal(s), but is connected to \",
                    xsd:string( ?cardinality ),
                    \" literal(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:DataExactCardinality_QualifiedCardinality
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Class Expressions - Data Property Cardinality Restrictions - Exact Cardinality" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                owl2spin:cv 
            	    rdf:type spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#        	    ?this ?DPE ?l .
#               ?this rdf:type ?CE .
#        	    -----
                ?this ?DPE ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                ?this rdf:type ?CE .
 
#	            DataExactCardinality ( Exact DPE DR )
#	            -----
		        ?CE rdf:type owl:Restriction .
		        ?CE owl:qualifiedCardinality ?Exact .
		        ?CE owl:onProperty ?DPE .
		        ?CE owl:onClass ?DR .
		        
#		        ?cardinality != ?Exact
#               -----
		        BIND ( owl2spin:qualifiedCardinalityDPE( ?this, ?DPE, ?DR ) AS ?c ) .
		        BIND( STRDT ( STR ( ?Exact ), xsd:nonNegativeInteger ) AS ?ExactCardinality )
		        BIND( STRDT ( STR ( ?c ), xsd:nonNegativeInteger ) AS ?cardinality )
		        FILTER ( ?cardinality != ?ExactCardinality ) .		    
   
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataExactCardinality ( \", 
                    xsd:string( ?Exact ), 
                    \" \", 
                    xsd:string( ?DPE ), 
                    \" \", 
                    xsd:string( ?DR ), 
                    \" ) | The individual '\", 
                    xsd:string( ?this ), 
                    \"' can only be connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' to exactly \", 
                    xsd:string( ?Exact ),
                    \" different literal(s) in '\", 
                    xsd:string( ?DR ),
                    \"', but is connected to \",
                    xsd:string( ?cardinality ),
                    \" literal(s).\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#   CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?property ;
#		    spin:violationSource ?violationSource }
#   WHERE {
#	    for all classes in the class hierarchy of ?this
#	    -----
#		?this a ?type .
#		?type sp:path ?class .
# 
#	    DataExactCardinality ( Exact DPE DR )
#	    -----
#		?class a owl:Restriction .
#		{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#		?class owl:onProperty ?DPE .
#       OPTIONAL { ?class owl:onClass ?DR_tmp } .
#	    BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) 
#
#	    qualifiedCardinality != Exact
#	    -----
#	    BIND ( ( qualifiedCardinality ( OPE, CE ) ) AS ?qualifiedCardinality ) . }
#		FILTER ( qualifiedCardinality > ?Exact ) .
#
#       DPE is data property expression	
#
#		BIND ( ( ... ) AS ?label ) . }
owl2spin:DataExactCardinality_old
	a spin:Template;
	rdfs:subClassOf spin:Templates;
	spin:labelTemplate "DataExactCardinality";
	rdfs:label "DataExactCardinality";
	rdfs:comment "DataExactCardinality";
	spin:body [
		a sp:Construct;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#	    	for all classes in the class hierarchy of ?this
#	    	-----
#			?this a ?type .
#			?type sp:path ?class .

			[   sp:subject [ sp:varName "this" ];
			    sp:predicate rdf:type;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ];
				sp:path [ 
				    a sp:ModPath;
					sp:modMax -2;
					sp:modMin 0;
					sp:subPath rdfs:subClassOf ];
			    sp:object [ sp:varName "class" ] ] 
		
#	    	DataExactCardinality ( Exact DPE DR )
#	    	-----
#			?class a owl:Restriction .
#			{ ?class owl:cardinality ?Exact } UNION { ?class owl:qualifiedCardinality ?Exact } .
#			?class owl:onProperty ?DPE .
#           OPTIONAL { ?class owl:onClass ?DR_tmp } .
#			BIND( ( IF( BOUND( ?DR_tmp ), ?DR_tmp, rdfs:Literal ) ) AS ?DR ) .
		
			[   sp:subject [ sp:varName "class" ];
				sp:predicate rdf:type;
				sp:object owl:Restriction ]
			[   a sp:Union ;
                sp:elements ( 
				(
                    [   sp:subject [ sp:varName "class" ];
				        sp:predicate owl:cardinality;
				        sp:object [ sp:varName "Exact" ] ]    
				) 
                (
                    [	sp:subject [ sp:varName "class" ];
				        sp:predicate owl:qualifiedCardinality;
				        sp:object [ sp:varName "Exact" ] ]
				))]
			[   sp:subject [ sp:varName "class" ];
			    sp:predicate owl:onProperty;
			    sp:object [ sp:varName "DPE" ] ]
			[   a sp:Optional ;
                sp:elements (
				    [   sp:subject [ sp:varName "class" ] ;
                        sp:predicate owl:onClass ;
                        sp:object  [ sp:varName "DR_tmp" ] ] ) ]
            [   a sp:Bind ;
                sp:expression 
					[   a sp:if ;
                        sp:arg1 [ 
							a sp:bound ;
							sp:arg1 [ sp:varName "DR_tmp" ] ] ;
                        sp:arg2 [ sp:varName "DR_tmp" ] ;
                        sp:arg3 rdfs:Literal ] ;
                    sp:variable [ sp:varName "DR" ] ]	
				
#	    	qualifiedCardinality != Exact
#	    	-----
#	    	BIND ( ( qualifiedCardinality ( DPE, DR ) ) AS ?qualifiedCardinality ) . 
#			FILTER ( qualifiedCardinality != ?Exact ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "qualifiedCardinality" ];
				sp:expression [
					a functions:qualifiedCardinalityDataProperties;
					sp:arg1 [ sp:varName "DPE" ] ;
					sp:arg2 [ sp:varName "DR" ] ] ]     
			[   a sp:Filter;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "qualifiedCardinality" ];
					sp:arg2 [ sp:varName "Exact" ] ] ]
					
#           DPE is data property expression		
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
							
#			BIND ( ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataExactCardinality ( " ;
					sp:arg2 [ sp:varName "Exact" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DPE" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "DR" ] ;
					sp:arg7 " )" ] ] ) ].	
	
# -----			

# ---------------
# Class Expressions - Object Property Restrictions - Existential Quantification


# description
# -----
# An existential class expression ObjectSomeValuesFrom( OPE CE ) consists of an object property expression OPE 
# and a class expression CE, and it contains all those individuals that are connected by OPE to an individual that is an instance of CE. 

# definition
# -----
# ObjectSomeValuesFrom := 'ObjectSomeValuesFrom' '(' ObjectPropertyExpression ClassExpression ')' 


owl2spin:ObjectSomeValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectSomeValuesFrom" ;
	rdfs:label "ObjectSomeValuesFrom" ;
	rdfs:comment "ObjectSomeValuesFrom" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where (  
#       WHERE {
#    		?this rdf:type ?subC . 
#    		?subC rdfs:subClassOf* ?C .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#    		?C owl:someValuesFrom ?CE .
#		    ?C owl:onProperty ?OPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:someValuesFrom ;
				sp:object [ sp:varName "CE" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "OPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
				
#    		FILTER ( sp:not ( spl:hasValueOfType ( ?this, ?OPE, ?CE ) ) ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValueOfType ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "OPE" ] ;
						sp:arg3 [ sp:varName "CE" ] ] ] ]
						
#           OPE is object property expression	
#           -----
#           FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectSomeValuesFrom ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ].
					
# -----

# ---------------
# Class Expressions - Object Property Restrictions - Universal Quantification


# description
# -----
# A universal class expression ObjectAllValuesFrom( OPE CE ) consists of an object property expression OPE and a class expression CE, 
# and it contains all those individuals that are connected by OPE only to individuals that are instances of CE. 

# definition
# -----
# ObjectAllValuesFrom := 'ObjectAllValuesFrom' '(' ObjectPropertyExpression ClassExpression ')' 	


# CONSTRUCT {
#   _:violation 
#     a spin:ConstraintViolation ;
#     rdfs:label ?label
#     spin:violationRoot ?violationRoot ;
#     spin:violationPath ?violationPath }
# WHERE {
#    ?C owl:allValuesFrom ?CE .
#    ?C owl:onProperty ?OPE . 
#    ?C a owl:Restriction .
#    -----
#
#    ?this a ?subC . 
#    ?subC rdfs:subClassOf* ?C .
#    -----
#
#	 ?this ?subOPE ?object .	
#	 ?subOPE rdfs:subPropertyOf* ?OPE .
#    -----
#
#    FILTER ( sp:not ( spl:instanceOf ( ?object, ?CE ) ) ) . 
#
#    OPE is object property expression	
#    -----
#    FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
#
#	 BIND ( ( ... ) AS ?label ) . }
owl2spin:ObjectAllValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectAllValuesFrom" ;
	rdfs:label "ObjectAllValuesFrom" ;
	rdfs:comment "ObjectAllValuesFrom" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object "" ] );
		sp:where (  				
#    		?C owl:allValuesFrom ?CE .
#		    ?C owl:onProperty ?OPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:allValuesFrom ;
				sp:object [ sp:varName "CE" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "OPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
	
#    		?this rdf:type ?subC . 
#    		?subC rdfs:subClassOf* ?C .
#           -----

			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
	
#		    ?this ?subOPE ?object .	
#		    ?subOPE rdfs:subPropertyOf* ?OPE .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subOPE" ] ;
				sp:object [ sp:varName "object" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subOPE" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subPropertyOf ] ;
			    sp:object [ sp:varName "OPE" ] ]
				
#    		FILTER ( sp:not ( spl:instanceOf ( ?object, ?CE ) ) ) . 
#			[   a sp:Filter ;
#				sp:expression [ 
#					a sp:not ;
#				    sp:arg1 [ 
#						a spl:instanceOf ;
#				        sp:arg1 [ sp:varName "object" ] ;
#						sp:arg2 [ sp:varName "CE" ] ] ] ]

#           FILTER NOT EXISTS { ?object rdf:type ?CE . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object [ sp:varName "CE" ] ] ) ] ]
				
#           OPE is object property expression	
#           -----
#           FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
				
#    		BIND ( ... ) AS ?label ) .
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectAllValuesFrom ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ].
	
# -----	

# ---------------
# Class Expressions - Object Property Restrictions - Individual Value Restriction


# description
# -----
# A has-value class expression ObjectHasValue( OPE a ) consists of an object property expression OPE and an individual a, 
# and it contains all those individuals that are connected by OPE to a. 

# definition
# -----
# ObjectHasValue := 'ObjectHasValue' '(' ObjectPropertyExpression Individual ')' 


owl2spin:ObjectHasValue
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectHasValue" ;
	rdfs:label "ObjectHasValue" ;
	rdfs:comment "ObjectHasValue" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object [ sp:varName "property" ] ] );
		sp:where (  
#       WHERE {
#		    ?this rdf:type ?subC . 
#		    ?subC rdfs:subClassOf* ?C . 
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#	        ?C rdf:type owl:Restriction ;
#   	    ?C owl:onProperty ?OPE ;
#       	?C owl:hasValue ?I . 
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "OPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:hasValue ;
				sp:object [ sp:varName "I" ] ]
			
#           FILTER ( sp:not ( spl:hasValue ( ?this, ?OPE, ?I ) ) ) .
#           -----			
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValue ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "OPE" ] ;
						sp:arg3 [ sp:varName "I" ] ] ] ]

#           OPE is object property expression	
#           -----
#           FILTER EXISTS { ?this ?OPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "OPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectHasValue ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "I" ] ;
					sp:arg5 " )" ] ] ) ].
					
# -----

# ---------------
# Class Expressions - Object Property Restrictions - Self-Restriction


owl2spin:ObjectHasSelf
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
#   spin:violationSource:
    spin:labelTemplate "Class Expressions - Self-Restriction" ;
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	                
	    		?this rdf:type ?C .
	    		
	    		?C rdf:type owl:Restriction .
	    		?C owl:onProperty ?OPE .
	    		?C owl:hasSelf "true"^^xsd:boolean .

				FILTER NOT EXISTS { ?this ?OPE ?this . }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectHasSelf ( \", 
                    xsd:string( ?OPE ),
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

# ---------------
# Class Expressions - Data Property Restrictions - Existential Quantification


# description
# -----
# An existential class expression DataSomeValuesFrom( DPE1 ... DPEn DR ) consists of n data property expressions DPEi, 1 ≤ i ≤ n, 
# and a data range DR whose arity MUST be n. Such a class expression contains all those individuals that are connected by DPEi to literals lti, 1 ≤ i ≤ n, 
# such that the tuple ( lt1 , ..., ltn ) is in DR. 

# definition
# -----
# DataSomeValuesFrom := 'DataSomeValuesFrom' '(' DataPropertyExpression { DataPropertyExpression } DataRange ')


owl2spin:DataSomeValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataSomeValuesFrom" ;
	rdfs:label "DataSomeValuesFrom" ;
	rdfs:comment "DataSomeValuesFrom" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object "" ] );
		sp:where (  
#	 		for all classes in the class hierarchy of ?this
#    		-----
#    		?this a ?type . 
#    		?type sp:path ?C . 

			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "type" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "type" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#    		?C owl:someValuesFrom ?DR .
#		    ?C owl:onProperty ?DPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:someValuesFrom ;
				sp:object [ sp:varName "DR" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
				
#    		FILTER ( sp:not ( spl:hasValueOfType ( ?this, ?DPE, ?DR ) ) ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValueOfType ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "DPE" ] ;
						sp:arg3 [ sp:varName "DR" ] ] ] ]
						
#           DPE is data property expression	
#           -----
#           FILTER NOT EXISTS { ?this ?DPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#			BIND ( ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataSomeValuesFrom ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Class Expressions - Data Property Restrictions - Universal Quantification


# description
# -----
# A universal class expression DataAllValuesFrom( DPE1 ... DPEn DR ) consists of n data property expressions DPEi, 1 ≤ i ≤ n, and a data range DR whose arity MUST be n. 
# Such a class expression contains all those individuals that are connected by DPEi only to literals lti, 1 ≤ i ≤ n, such that each tuple ( lt1 , ..., ltn ) is in DR. 

# definition
# -----
# DataAllValuesFrom := 'DataAllValuesFrom' '(' DataPropertyExpression { DataPropertyExpression } DataRange ')' 


owl2spin:DataAllValuesFrom
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataAllValuesFrom" ;
	rdfs:label "DataAllValuesFrom" ;
	rdfs:comment "DataAllValuesFrom" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object "" ] );
		sp:where (  	
#		WHERE {
		
#    		?C owl:allValuesFrom ?DR .
#		    ?C owl:onProperty ?DPE . 
#           ?C a owl:Restriction .
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:allValuesFrom ;
				sp:object [ sp:varName "DR" ] ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
	
#    		?this rdf:type ?subC . 
#    		?subC rdfs:subClassOf* ?C .
#           -----

			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
	
#		    ?this ?subDPE ?object .	
#		    ?subDPE rdfs:subPropertyOf* ?DPE .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subDPE" ] ;
				sp:object [ sp:varName "object" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subDPE" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subPropertyOf ] ;
			    sp:object [ sp:varName "DPE" ] ]
				
#    		FILTER ( sp:not ( spl:instanceOf ( ?object, ?DR ) ) ) . 
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:instanceOf ;
				        sp:arg1 [ sp:varName "object" ] ;
						sp:arg2 [ sp:varName "DR" ] ] ] ]
				
#           DPE is data property expression	
#           -----
#           FILTER NOT EXISTS { ?this ?DPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
				
#    		BIND ( ... ) AS ?label ) . }
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataAllValuesFrom ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ].
	
# -----	

# ---------------
# Class Expressions - Data Property Restrictions - Literal Value Restriction


# description
# -----


# definition
# -----
# DataHasValue := 'DataHasValue' '(' DataPropertyExpression Literal ')' 


owl2spin:DataHasValue
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "DataHasValue" ;
	rdfs:label "DataHasValue" ;
	rdfs:comment "DataHasValue" ;
	spin:body [
		a sp:Construct ;
# 		CONSTRUCT {
#   		_:violation 
#     			a spin:ConstraintViolation ;
#     			rdfs:label ?label
#     			spin:violationRoot ?this ;
#     			spin:violationPath ?violationPath }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object [ sp:varName "property" ] ] );
		sp:where (  
#       WHERE {
#		    ?this rdf:type ?subC . 
#		    ?subC rdfs:subClassOf* ?C . 
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "subC" ] ]
			[   a sp:TriplePath;
				sp:subject [ sp:varName "subC" ] ;
				sp:path [ 
				    a sp:ModPath ;
					sp:modMax -2 ;
					sp:modMin 0 ;
					sp:subPath rdfs:subClassOf ] ;
			    sp:object [ sp:varName "C" ] ]
				
#	        ?C rdf:type owl:Restriction ;
#   	    ?C owl:onProperty ?DPE ;
#       	?C owl:hasValue ?L . 
#           -----
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:Restriction ]
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:onProperty ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject [ sp:varName "C" ] ;
			    sp:predicate owl:hasValue ;
				sp:object [ sp:varName "L" ] ]
			
#           FILTER ( sp:not ( spl:hasValue ( ?this, ?DPE, ?L ) ) ) .
#           -----			
			[   a sp:Filter ;
				sp:expression [ 
					a sp:not ;
				    sp:arg1 [ 
						a spl:hasValue ;
				        sp:arg1 [ sp:varName "this" ] ;
						sp:arg2 [ sp:varName "DPE" ] ;
						sp:arg3 [ sp:varName "L" ] ] ] ]

#           DPE is data property expression	
#           -----
#           FILTER NOT EXISTS { ?this ?DPE ?object . ?object rdf:type owl:Thing . }	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "DPE" ] ;
				            sp:object [ sp:varName "object" ] ]
						[   sp:subject [ sp:varName "object" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
						
#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataHasValue ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "L" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Axioms - Class Expression Axioms - Disjoint Classes


# -----
owl2spin:DisjointClasses
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
#   spin:violationSource:
    spin:labelTemplate "OWL 2 - Axioms - Class Expressions Axioms - Disjoint Classes" ;
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {
                ?this rdf:type ?CE1 .
                ?this rdf:type ?CE2 .
		        ?CE1 owl:disjointWith ?CE2 .                
                FILTER ( ?CE1 != ?CE2 ) .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DisjointClasses ( \", 
                    xsd:string( ?CE1 ), 
                    \" \", 
                    xsd:string( ?CE2 ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
					
# -----

# ---------------
# Axioms - Class Expression Axioms - Disjoint Union of Class Expressions


owl2spin:DisjointUnion_2CE_1
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    
#   spin:violationSource:
#   -----
    spin:labelTemplate "OWL 2 - Axioms - Class Expression Axioms - Disjoint Union of Class Expressions" ;
    
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	 
            	?this rdf:type ?C .
               
#	    		?C owl:disjointUnionOf ( ?CE1 ?CE2 ) . 
#       		-----
	    		?C owl:disjointUnionOf ?DCE .
	    		?DCE rdf:first ?CE1 .
	    		?DCE rdf:rest ?r1 .
	    		?r1 rdf:first ?CE2 .
	    		?r1 rdf:rest ?r2 .
	    		FILTER ( ?r2 = rdf:nil ) .

#	    		each instance of C is an instance of exactly one CEi
#       		-----
	    		?this rdf:type ?CE1 .
				?this rdf:type ?CE2 .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DisjointUnion ( \", 
                    xsd:string( ?C ), 
                    \" \", 
                    xsd:string( ?CE1 ),
                    \" \", 
                    xsd:string( ?CE2 ),  
                    \" )\", 
                    \" - each instance of \",
                    xsd:string( ?C ),  
                    \" must also be an instance of exactly one of \",
                    xsd:string( ?CE1 ),
                    \" and \", 
                    xsd:string( ?CE2 ) ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:DisjointUnion_2CE_2
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    
#   spin:violationSource:
#   -----
    spin:labelTemplate "OWL 2 - Axioms - Class Expression Axioms - Disjoint Union of Class Expressions" ;
    
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	 
            	?this rdf:type ?CE1 .
               
#	    		?C owl:disjointUnionOf ( ?CE1 ?CE2 ) . 
#       		-----
	    		?C owl:disjointUnionOf ?DCE .
	    		?DCE rdf:first ?CE1 .
	    		?DCE rdf:rest ?r1 .
	    		?r1 rdf:first ?CE2 .
	    		?r1 rdf:rest ?r2 .
	    		FILTER ( ?r2 = rdf:nil ) .

#       		each instance of CE1 is an instance of C
#       		-----
       			FILTER NOT EXISTS { ?this rdf:type ?C }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DisjointUnion ( \", 
                    xsd:string( ?C ), 
                    \" \", 
                    xsd:string( ?CE1 ),
                    \" \", 
                    xsd:string( ?CE2 ),  
                    \" )\",
                    \" - each instance of \",
                    xsd:string( ?CE1 ),  
                    \" must also be an instance of \",
                    xsd:string( ?C ) ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

owl2spin:DisjointUnion_2CE_3
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    
#   spin:violationSource:
#   -----
    spin:labelTemplate "OWL 2 - Axioms - Class Expression Axioms - Disjoint Union of Class Expressions" ;
    
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    spin:violationPath rdf:type ;
                    rdfs:label ?violationMessage .
            }
            WHERE {	 
            	?this rdf:type ?CE2 .
               
#	    		?C owl:disjointUnionOf ( ?CE1 ?CE2 ) . 
#       		-----
	    		?C owl:disjointUnionOf ?DCE .
	    		?DCE rdf:first ?CE1 .
	    		?DCE rdf:rest ?r1 .
	    		?r1 rdf:first ?CE2 .
	    		?r1 rdf:rest ?r2 .
	    		FILTER ( ?r2 = rdf:nil ) .

#       		each instance of CE2 is an instance of C
#       		-----
       			FILTER NOT EXISTS { ?this rdf:type ?C }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DisjointUnion ( \", 
                    xsd:string( ?C ), 
                    \" \", 
                    xsd:string( ?CE1 ),
                    \" \", 
                    xsd:string( ?CE2 ),  
                    \" )\",
                    \" - each instance of \",
                    xsd:string( ?CE2 ),  
                    \" must also be an instance of \",
                    xsd:string( ?C ) ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
					
# -----

# ---------------
# Axioms - Object Property Axioms - Object Subproperties


# description
# -----
# This axiom states that the object property expression OPE1 is a subproperty of the object property expression OPE2 -
# that is, if an individual x is connected by OPE1 to an individual y, then x is also connected by OPE2 to y. 

# definition
# -----
# SubObjectPropertyOf := 'SubObjectPropertyOf' '(' axiomAnnotations subObjectPropertyExpression superObjectPropertyExpression ')'	


# -----
owl2spin:SubObjectPropertyOf
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "SubObjectPropertyOf" ;
	rdfs:label "SubObjectPropertyOf" ;
	rdfs:comment "SubObjectPropertyOf" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?property }
		sp:templates ( 
			[   sp:subject _:violation;
				sp:predicate rdf:type;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation; 
				sp:predicate rdfs:label;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation;
				sp:predicate spin:violationRoot;
				sp:object spin:_this ]		
			[   sp:subject _:violation;
				sp:predicate spin:violationPath;
				sp:object [ sp:varName "subOPE" ] ] );
		sp:where ( 
#       WHERE {
#		    ?subOPE rdfs:subPropertyOf ?superOPE .
#           -----
			[   sp:subject [ sp:varName "subOPE" ] ;
			    sp:predicate rdfs:subPropertyOf ;
				sp:object [ sp:varName "superOPE" ] ]
				
#           ?this ?subOPE ?y .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "subOPE" ] ;
				sp:object [ sp:varName "y" ] ]
			
				
#           FILTER NOT EXISTS { ?this ?superOPE ?y } .	
#           -----
            [   a sp:Filter ;
                sp:expression [
				    a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "superOPE" ] ;
                            sp:object [ sp:varName "y" ] ] ) ] ] 
							
#		    BIND ( ( ... ) AS ?label ) . }	
#           -----								
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "SubObjectPropertyOf ( " ;
					sp:arg2 [ sp:varName "subOPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "superOPE" ] ] ] ) ] .

# -----

# ---------------
# Axioms - Object Property Axioms - Object Property Chains


# description
# -----
# if an individual x is connected by a sequence of object property expressions OPE1, ..., OPEn with an individual y, 
# then x is also connected with y by the object property expression OPE.

# definition
# -----	
# SubObjectPropertyOf ( axiomAnnotations ObjectPropertyChain ( ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ) superObjectPropertyExpression )

# 2 OPE
# -----
owl2spin:ObjectPropertyChain_2OPE
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectPropertyChain" ;
	rdfs:label "ObjectPropertyChain" ;
	rdfs:comment "ObjectPropertyChain" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?violationPath ;
#               spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "superOPE" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object owl2spin:ObjectPropertyChain_TwoObjectPropertyExpressions ] ) ;
		sp:where ( 
#		WHERE {
#		    ?superOPE owl:propertyChainAxiom ?objectPropertyChain .
#           -----
#			?objectPropertyChain rdf:first ?first_1 .
#			?objectPropertyChain rdf:rest ?rest_1 .
#			?rest_1 rdf:first ?first_2 .
#			?rest_1 rdf:rest ?rest_2 .
#           FILTER ( ?rest_2 = rdf:nil )	
			
			[   sp:subject [ sp:varName "superOPE" ] ;
			    sp:predicate owl:propertyChainAxiom ;
				sp:object [ sp:varName "objectPropertyChain" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE1" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_2" ];
					sp:arg2 rdf:nil ] ]
					
#           ?this ?OPE1 ?a . ?a ?OPE2 ?b
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ]
			[   sp:subject [ sp:varName "a" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "b" ] ]
		
#           FILTER NOT EXISTS { ?this ?superOPE ?b } .  
#           -----		
            [   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "superOPE" ] ;
				            sp:object [ sp:varName "b" ] ] ) ] ]
							
#    		BIND ( ... ) AS ?label ) . }
#           -----			
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "SubObjectPropertyOf( ObjectPropertyChain( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " ) " ;
					sp:arg6 [ sp:varName "superOPE" ] ;
					sp:arg7 " )" ] ] ) ] .
		
# 3 OPE
# -----			
owl2spin:ObjectPropertyChain_3OPE
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "ObjectPropertyChain" ;
	rdfs:label "ObjectPropertyChain" ;
	rdfs:comment "ObjectPropertyChain" ;
	spin:body [
		a sp:Construct ;
#		CONSTRUCT {
#           _:violation 
#		        a spin:ConstraintViolation ;
#		        rdfs:label ?label
#               spin:violationRoot ?this ;
#               spin:violationPath ?violationPath ;
#               spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "superOPE" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object owl2spin:ObjectPropertyChain_ThreeObjectPropertyExpressions ] ) ;
		sp:where ( 
#       WHERE {
#		    ?superOPE owl:propertyChainAxiom ( ?OPE1 ?OPE2 ?OPE3 ) .
#           -----
			[   sp:subject [ sp:varName "superOPE" ] ;
			    sp:predicate owl:propertyChainAxiom ;
				sp:object [ sp:varName "objectPropertyChain" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE1" ] ]
			[   sp:subject [ sp:varName "objectPropertyChain" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_1" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE2" ] ]
			[   sp:subject [ sp:varName "rest_1" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_2" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "OPE3" ] ]
			[   sp:subject [ sp:varName "rest_2" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "rest_3" ] ]
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "rest_3" ];
					sp:arg2 rdf:nil ] ]
					
#           ?this ?OPE1 ?a . ?a ?OPE2 ?b . ?b ?OPE2 ?c .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ]
			[   sp:subject [ sp:varName "a" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "b" ] ]	
			[   sp:subject [ sp:varName "b" ] ;
			    sp:predicate [ sp:varName "OPE3" ] ;
				sp:object [ sp:varName "c" ] ]	
					
#           FILTER NOT EXISTS { ?this ?superOPE ?c } . 
            [   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate [ sp:varName "superOPE" ] ;
				            sp:object [ sp:varName "c" ] ] ) ] ]
							
#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "SubObjectPropertyOf( ObjectPropertyChain( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " " ;
					sp:arg6 [ sp:varName "OPE3" ] ;
					sp:arg7 " ) " ;
					sp:arg8 [ sp:varName "superOPE" ] ;
					sp:arg9 " )" ] ] ) ] .

# -----

# ---------------
# Axioms - Object Property Axioms - Equivalent Object Properties


# description
# -----
# An equivalent object properties axiom EquivalentObjectProperties( OPE1 ... OPEn ) states that all of the object property expressions OPEi, 1 ≤ i ≤ n, 
# are semantically equivalent to each other. This axiom allows one to use each OPEi as a synonym for each OPEj — 
# that is, in any expression in the ontology containing such an axiom, OPEi can be replaced with OPEj without affecting the meaning of the ontology.

# definition
# -----	
# EquivalentObjectProperties := 'EquivalentObjectProperties' '(' axiomAnnotations ObjectPropertyExpression ObjectPropertyExpression { ObjectPropertyExpression } ')' 


owl:Thing
    spin:rule [
        a sp:Construct ;
		rdfs:comment "EquivalentObjectProperties" ;
		sp:templates ( 
#           ?this ?OPE2 ?a
#           -----		
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "a" ] ] ) ;
		sp:where (
#       WHERE {
#		    ?OPE1 owl:equivalentProperty ?OPE2 . 
#           -----	
			[   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:equivalentProperty ;
				sp:object [ sp:varName "OPE2" ] ]
				
#           ?this ?OPE1 ?a
#           -----	
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ] ) ] ; 
				
    spin:rule [
        a sp:Construct ;
		rdfs:comment "EquivalentObjectProperties" ;
		sp:templates ( 
#           ?this ?OPE1 ?a
#           -----		
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE1" ] ;
				sp:object [ sp:varName "a" ] ] ) ;
		sp:where (
#       WHERE {
#		    ?OPE1 owl:equivalentProperty ?OPE2 . 
#           -----	
			[   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:equivalentProperty ;
				sp:object [ sp:varName "OPE2" ] ]
				
#           ?this ?OPE2 ?a
#           -----	
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE2" ] ;
				sp:object [ sp:varName "a" ] ] ) ] .

# -----

# ---------------
# Axioms - Object Property Axioms - Disjoint Object Properties


owl2spin:DisjointObjectProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Disjoint Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE1 ;
                    spin:violationPath ?OPE2 .
            }
            WHERE {	  
			    ?OPE1 owl:propertyDisjointWith ?OPE2 . 
			    ?this ?OPE1 ?y .
			    ?this ?OPE2 ?y .
			    ?y rdf:type owl:Thing . # ?OPE1 and ?OPE2 are OPEs
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DisjointObjectProperties ( \", 
                    xsd:string( ?OPE1 ), 
                    \" \", 
                    xsd:string( ?OPE2 ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

owl2spin:DisjointObjectProperties_old
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Disjoint Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
#		CONSTRUCT {
#           _:cv
#		        a spin:ConstraintViolation ;
#               spin:violationRoot ?this ;
#		        rdfs:label ?violationMessage ;
#               spin:violationPath ?OPE1 ;
#               spin:violationPath ?OPE2 ; 
#       }
		sp:templates ( 
			[   sp:subject _:cv ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[	sp:subject _:cv ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]	
			[   sp:subject _:cv ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[   sp:subject _:cv ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "OPE1" ] ]	 
			[   sp:subject _:cv ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "OPE2" ] ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE1 owl:propertyDisjointWith ?OPE2 . 
#           -----	
			[   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:propertyDisjointWith ;
				sp:object [ sp:varName "OPE2" ] ]
				
#			?this ?OPE1 ?y .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "OPE1" ] ;
                sp:object [ sp:varName "y" ] ]
                
#			?this ?OPE2 ?y .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "OPE2" ] ;
                sp:object [ sp:varName "y" ] ]
                
#			OPE
#           -----
			[   sp:subject [ sp:varName "y" ] ;
                sp:predicate rdf:type ;
                sp:object owl:Thing ]             
							
#           violation message
#           -----			
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DisjointObjectProperties ( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Axioms - Object Property Axioms - Inverse Object Properties


# description
# -----
# An inverse object properties axiom InverseObjectProperties( OPE1 OPE2 ) states that the object property expression OPE1 
# is an inverse of the object property expression OPE2. Thus, if an individual x is connected by OPE1 to an individual y, 
# then y is also connected by OPE2 to x, and vice versa. 

# definition
# -----	
# InverseObjectProperties := 'InverseObjectProperties' '(' axiomAnnotations ObjectPropertyExpression ObjectPropertyExpression ')' 


# -----
owl2spin:InverseObjectProperties
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "InverseObjectProperties" ;
	rdfs:label "InverseObjectProperties" ;
	rdfs:comment "InverseObjectProperties" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE1 owl:inverseOf ?OPE2 . 
#           -----
            [   sp:subject [ sp:varName "OPE1" ] ;
			    sp:predicate owl:inverseOf ;
				sp:object [ sp:varName "OPE2" ] ]

#           { ?this ?OPE1 ?y . FILTER NOT EXISTS { ?y ?OPE2 ?this } } 
#           UNION
#           { ?this ?OPE2 ?y . FILTER NOT EXISTS { ?y ?OPE1 ?this } } 
#           -----
			[   a sp:Union ;
                sp:elements ( 
					(   [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "OPE1" ] ;
                            sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter ;
                            sp:expression [
 							    a sp:notExists ;
                                sp:elements ( 
									[   sp:subject [ sp:varName "y" ] ;
                                        sp:predicate [ sp:varName "OPE2" ] ;
                                        sp:object [ sp:varName "this" ] ] ) ] ] ) 
					(   [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "OPE2" ] ;
                            sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter ;
                            sp:expression [
 							    a sp:notExists ;
                                sp:elements ( 
									[   sp:subject [ sp:varName "y" ] ;
                                        sp:predicate [ sp:varName "OPE1" ] ;
                                        sp:object [ sp:varName "this" ] ] ) ] ] ) ) ] 

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "InverseObjectProperties ( " ;
					sp:arg2 [ sp:varName "OPE1" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "OPE2" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Axioms - Object Property Axioms - Object Property Domain


owl2spin:ObjectPropertyDomain
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Object Property Domain" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
			    ?OPE rdfs:domain ?CE . 
                ?this ?OPE ?y .
				?y rdf:type owl:Thing . # ?OPE is OPE
				FILTER NOT EXISTS { ?this rdf:type ?CE } .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectPropertyDomain ( \", 
                    xsd:string( ?OPE ), 
                    \" \", 
                    xsd:string( ?CE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?OPE rdfs:domain ?CE . 
#       ?this ?OPE ?y .
#	    FILTER EXISTS { ?y rdf:type owl:Thing }
#       FILTER NOT EXISTS ( ?this rdf:type ?CE ) .
#		LET ( ( ... ) AS ?label ) . }
owl2spin:ObjectPropertyDomain_old
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Object Property Domain" ;
	rdfs:label "Object Property Domain" ;
	rdfs:comment "Object Property Domain" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdfs:domain ;
				sp:object [ sp:varName "CE" ] ]
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "OPE" ] ;
                sp:object [ sp:varName "y" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectPropertyDomain ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Axioms - Object Property Axioms - Object Property Range


owl2spin:ObjectPropertyRange
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Object Property Range" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
			    ?OPE rdfs:range ?CE . 
                ?x ?OPE ?this .
				?this rdf:type owl:Thing . # ?OPE is OPE
				FILTER NOT EXISTS { ?this rdf:type ?CE } .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ObjectPropertyRange ( \", 
                    xsd:string( ?OPE ), 
                    \" \", 
                    xsd:string( ?CE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .


#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?OPE rdfs:range ?CE . 
#       ?this ?OPE ?y .
#	    FILTER EXISTS { ?y rdf:type owl:Thing }
#       FILTER NOT EXISTS ( ?y rdf:type ?CE ) .
#		LET ( ( ... ) AS ?label ) . }
owl2spin:ObjectPropertyRange_old
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Object Property Range" ;
	rdfs:label "Object Property Range" ;
	rdfs:comment "Object Property Range" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdfs:range ;
				sp:object [ sp:varName "CE" ] ]		
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "OPE" ] ;
                sp:object [ sp:varName "y" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:exists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
                            sp:predicate rdf:type ;
                            sp:object owl:Thing ] ) ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "CE" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "ObjectPropertyRange ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "CE" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Axioms - Object Property Axioms - Functional Object Property


owl2spin:FunctionalObjectProperty
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Functional Object Property" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
			    ?OPE rdf:type owl:FunctionalProperty .
			    ?this ?OPE ?x . ?x rdf:type owl:Thing .
			    ?this ?OPE ?y . ?y rdf:type owl:Thing . 
			    FILTER ( ?x != ?y ) .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"FunctionalObjectProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

owl2spin:FunctionalObjectProperty_old
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "FunctionalObjectProperty" ;
	rdfs:label "FunctionalObjectProperty" ;
	rdfs:comment "FunctionalObjectProperty" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE rdf:type owl:FunctionalProperty . 
#           -----
            [   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:FunctionalProperty ]

#           ?this ?OPE ?x .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "OPE" ] ;
				sp:object [ sp:varName "x" ] ]
				
#           FILTER EXISTS { ?this ?OPE ?y . FILTER ( ?x != ?y ) . } .
#           -----
			[   a sp:Filter ;
				sp:expression [
					a sp:exists ;
					sp:elements ( 
						[   sp:subject [ sp:varName "this" ] ;
							sp:predicate [ sp:varName "OPE" ] ;
							sp:object [ sp:varName "y" ] ] 
						[   a sp:Filter;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "x" ];
								sp:arg2 [ sp:varName "y" ] ] ] ) ] ]

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "FunctionalProperty ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Axioms - Object Property Axioms - Inverse-Functional Object Properties


owl2spin:InverseFunctionalObjectProperty
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Inverse Functional Object Property" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
			    ?OPE rdf:type owl:InverseFunctionalProperty . 
			    ?x ?OPE ?this . ?this rdf:type owl:Thing .
			    ?y ?OPE ?this . ?this rdf:type owl:Thing . 
			    FILTER ( ?x != ?y ) .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"InverseFunctionalProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
owl2spin:InverseFunctionalObjectProperty_old
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "InverseFunctionalObjectProperty" ;
	rdfs:label "InverseFunctionalObjectProperty" ;
	rdfs:comment "InverseFunctionalObjectProperty" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?property ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ rdf:type rdf:Property ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#		    ?OPE rdf:type owl:InverseFunctionalProperty . 
#           -----
            [   sp:subject [ sp:varName "OPE" ] ;
			    sp:predicate rdf:type ;
				sp:object owl:InverseFunctionalProperty ]

#           ?x ?OPE ?this .
#           -----
			[   sp:subject [ sp:varName "x" ] ;
			    sp:predicate [ sp:varName "OPE" ] ;
				sp:object [ sp:varName "this" ] ]
				
#           FILTER EXISTS { ?y ?OPE ?this . FILTER ( ?x != ?y ) . } .
#           -----
			[   a sp:Filter ;
				sp:expression [
					a sp:exists ;
					sp:elements ( 
						[   sp:subject [ sp:varName "y" ] ;
							sp:predicate [ sp:varName "OPE" ] ;
							sp:object [ sp:varName "this" ] ] 
						[   a sp:Filter;
							sp:expression [ 
								a sp:ne;
								sp:arg1 [ sp:varName "x" ];
								sp:arg2 [ sp:varName "y" ] ] ] ) ] ]

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "InverseFunctionalProperty ( " ;
					sp:arg2 [ sp:varName "OPE" ] ;
					sp:arg3 " )" ] ] ) ].

# -----

# ---------------
# Axioms - Object Property Axioms - Reflexive Object Properties


# no constraint checking needed


owl2spin:ReflexiveObjectProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Reflexive Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
			    
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"ReflexiveObjectProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----

# ---------------
# Axioms - Object Property Axioms - Irreflexive Object Properties


owl2spin:IrreflexiveObjectProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Irreflexive Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
                ?OPE rdf:type owl:IrreflexiveProperty . 
			    ?this ?OPE ?this . ?this rdf:type owl:Thing .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"IrreflexiveObjectProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----

# ---------------
# Axioms - Object Property Axioms - Symmetric Object Properties


owl2spin:SymmetricObjectProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Symmetric Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
                ?OPE rdf:type owl:SymmetricProperty . 
			    ?this ?OPE ?y . 
			    ?this rdf:type owl:Thing .
			    FILTER NOT EXISTS { ?y ?OPE ?this }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"SymmetricObjectProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----

# ---------------
# Axioms - Object Property Axioms - Asymmetric Object Properties


owl2spin:AsymmetricObjectProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Asymmetric Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
                ?OPE rdf:type owl:AsymmetricProperty . 
			    ?this ?OPE ?y . 
			    ?this rdf:type owl:Thing .
			    FILTER EXISTS { ?y ?OPE ?this }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"AsymmetricObjectProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----

# ---------------
# Axioms - Object Property Axioms - Transitive Object Properties


owl2spin:TransitiveObjectProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Object Property Axioms - Transitive Object Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
            }
            WHERE {	  
                ?OPE rdf:type owl:TransitiveProperty . 
			    ?this ?OPE ?y . ?y rdf:type owl:Thing .
			    ?y ?OPE ?z . ?z rdf:type owl:Thing .
			    FILTER NOT EXISTS { ?this ?OPE ?z }
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"TransitiveObjectProperty ( \", 
                    xsd:string( ?OPE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# -----

# ---------------
# Axioms - Data Property Axioms - Disjoint Data Properties


owl2spin:DisjointDataProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Data Property Axioms - Disjoint Data Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?PDE1 ;
                    spin:violationPath ?DPE2 .
            }
            WHERE {	  
			    ?DPE1 owl:propertyDisjointWith ?DPE2 . 
			    ?this ?DPE1 ?y .
			    ?this ?DPE2 ?y .
			    FILTER NOT EXISTS { ?y rdf:type owl:Thing } # ?DPE1 and ?DPE2 are DPEs
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DisjointDataProperties ( \", 
                    xsd:string( ?DPE1 ), 
                    \" \", 
                    xsd:string( ?DPE2 ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# ---------------
# Axioms - Data Property Axioms - Data Property Domain


owl2spin:DataPropertyDomain
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Data Property Axioms - Data Property Domain" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
            }
            WHERE {	  
			    ?DPE rdfs:domain ?CE . 
                ?this ?DPE ?y .
				FILTER NOT EXISTS { ?y rdf:type owl:Thing } # ?DPE is DPE
				FILTER NOT EXISTS { ?this rdf:type ?CE } .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataPropertyDomain ( \", 
                    xsd:string( ?DPE ), 
                    \" \", 
                    xsd:string( ?CE ), 
                    \" )\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .

#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?DPE rdfs:domain ?DR . 
#	    ?this ?DPE ?y . 
#       FILTER NOT EXISTS ( ?y rdf:type owl:Thing . ) .
#       FILTER NOT EXISTS ( ?this rdf:type ?DR ) .
#		LET ( ( ... ) AS ?label ) . }
owl2spin:DataPropertyDomain_old
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Data Property Domain" ;
	rdfs:label "Data Property Domain" ;
	rdfs:comment "Data Property Domain" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "DPE" ] ;
			    sp:predicate rdfs:domain ;
				sp:object [ sp:varName "DR" ] ]		
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "DPE" ] ;
                sp:object [ sp:varName "y" ] ]	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object owl:Thing ] ) ] ]	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "this" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "DR" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataPropertyDomain ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----    

# ---------------
# Axioms - Data Property Axioms - Data Property Range


owl2spin:DataPropertyRange
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Data Property Axioms - Data Property Range" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
            }
            WHERE {	  
                ?DPE rdfs:range ?DR . 
               	
               	?this ?DPE ?l .
				FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
					
				BIND ( DATATYPE( ?l ) AS ?datatype ) .
				FILTER ( ?datatype != ?DR ) .
                    
#               testing
#               -----
                BIND ( CONCAT( 
                    \"literal: \", 
                    xsd:string( ?l ), 
                    \" | DATATYPE( literal ): \", 
                    xsd:string( ?datatype ), 
                    \" | DR: \", 
                    xsd:string( ?DR ), 
                    \" )\" ) 
                    AS ?testing ) . 
				            
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"DataPropertyRange ( \", 
                    xsd:string( ?l ), 
                    \" \", 
                    xsd:string( ?DR ), 
                    \" ) | \",
                    \"The datatype of the literal '\", 
                    xsd:string( ?l ), 
                    \"' is '\", 
                    xsd:string( ?datatype ), 
                    \"' but must be '\", 
                    xsd:string( ?DR ), 
                    \"'\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
#	CONSTRUCT {
#	    _:violation 
#		    a spin:ConstraintViolation ;
#			rdfs:label ?label
#		    spin:violationRoot ?this ;
#		    spin:violationPath ?violationPath ;
#		    spin:violationSource ?violationSource }
#	WHERE {
#		?DPE rdfs:range ?DR . 
#	    ?this ?DPE ?y . 
#       FILTER NOT EXISTS ( ?y rdf:type owl:Thing . ) .
#       FILTER NOT EXISTS ( ?y rdf:type ?DR ) .
#		LET ( ( ... ) AS ?label ) . }
owl2spin:DataPropertyRange_old
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Data Property Range" ;
	rdfs:label "Data Property Range" ;
	rdfs:comment "Data Property Range" ;
	spin:body [
		a sp:Construct ;
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object "" ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
			[   sp:subject [ sp:varName "DPE" ] ;
			    sp:predicate rdfs:range ;
				sp:object [ sp:varName "DR" ] ]		
			[   sp:subject [ sp:varName "this" ] ;
                sp:predicate [ sp:varName "DPE" ] ;
                sp:object [ sp:varName "y" ] ]
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object owl:Thing ] ) ] ]	
			[   a sp:Filter ;
                sp:expression [
			        a sp:notExists ;
                    sp:elements (
						[   sp:subject [ sp:varName "y" ] ;
			                sp:predicate rdf:type ;
				            sp:object [ sp:varName "DR" ] ] ) ] ]	
			[   a sp:Let;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "DataPropertyRange ( " ;
					sp:arg2 [ sp:varName "DPE" ] ;
					sp:arg3 " " ;
					sp:arg4 [ sp:varName "DR" ] ;
					sp:arg5 " )" ] ] ) ] .

# -----

# ---------------
# Axioms - Data Property Axioms - Functional Data Properties


owl2spin:FunctionalDataProperties
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Data Property Axioms - Functional Data Properties" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
            CONSTRUCT {
                _:cv 
                	a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
            }
            WHERE {	  
			    ?DPE rdf:type owl:FunctionalProperty .
			    ?this ?DPE ?x .
			    ?this ?DPE ?y . 
			    FILTER NOT EXISTS { ?x rdf:type owl:Thing } . # ?DPE is DPE
			    FILTER ( ?x != ?y ) .
                
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"FunctionalDataProperty ( \", 
                    xsd:string( ?DPE ), 
                    \" ) | \", 
                    \" For the individual '\", 
                    xsd:string( ?this ), 
                    \"', there can be at most one distinct literal y such that the individual is connected by '\", 
                    xsd:string( ?DPE ), 
                    \"' with y, but is related to the literals '\", 
                    xsd:string( ?x ), 
                    \"' and '\", 
                    xsd:string( ?y ),
                    \"'\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# ----

# ---------------
# Axioms - Keys


owl2spin:HasKey
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Keys" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                _:cv 
            	    a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?PE1 .
        	}
        	WHERE {
                ?CE owl:hasKey ?PEs .  
				?PEs rdf:first ?PE1 .
				?PEs rdf:rest ?r1 .
    		    FILTER ( ?r1 = rdf:nil ) .
    		    
    		    ?this rdf:type ?CE .
    		    ?this ?PE1 ?v .
    		    ?x ?PE1 ?v . 
    		    ?x rdf:type ?CE .
    		    FILTER ( ?this != ?x ) .
        		    
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"HasKey( \", 
                    xsd:string( ?CE ), 
                    \" ( \", 
                    xsd:string( ?PE1 ), 
                    \" ) ) | The individuals '\", 
                    xsd:string( ?this ), 
                    \"' and '\", 
                    xsd:string( ?x ), 
                    \"' of the class expression '\", 
                    xsd:string( ?CE ), 
                    \"' coincide the value '\", 
                    xsd:string( ?v ), 
                    \"' of the property expression '\", 
                    xsd:string( ?PE1 ), 
                    \"', but no 2 distinct individuals can coincide the value of this property expression.\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# ----

# ---------------
# Axioms - Assertions - Negative Object Property Assertions 


owl2spin:NegativeObjectPropertyAssertion
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Assertions - Negative Object Property Assertions" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                _:cv 
            	    a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?OPE .
        	}
        	WHERE {
#               NegativeObjectPropertyAssertion ( axiomAnnotations ObjectPropertyExpression sourceIndividual targetIndividual )
#				-----
			    ?negativeObjectPropertyAssertion 
			        a owl:NegativePropertyAssertion ;
			        owl:sourceIndividual ?sourceIndividual ;
			        owl:assertionProperty ?OPE ;
			        owl:targetIndividual ?targetIndividual .
				        
#				ObjectPropertyAssertion( ObjectPropertyExpression sourceIndividual targetIndividual ) 
#               ----
                ?sourceIndividual ?OPE ?targetIndividual . 
                ?targetIndividual rdf:type owl:Thing . # ?OPE is OPE
                
                FILTER ( ?this = ?sourceIndividual ) .
        		    
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"NegativeObjectPropertyAssertion ( \", 
                    xsd:string( ?OPE ), 
                    \" \", 
                    xsd:string( ?sourceIndividual ), 
                    \" \", 
                    xsd:string( ?targetIndividual ), 
                    \" ) | The individual '\", 
                    xsd:string( ?sourceIndividual ), 
                    \"' must not have to be connected by the object property expression '\", 
                    xsd:string( ?OPE ), 
                    \"' to the individual '\", 
                    xsd:string( ?targetIndividual ),
                    \"'.\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# ----

# ---------------
# Axioms - Assertions - Negative Data Property Assertions 


owl2spin:NegativeDataPropertyAssertion
	a spin:ConstructTemplate ;
    rdfs:subClassOf spin:ConstructTemplates ;
    spin:labelTemplate "Axioms - Assertions - Negative Data Property Assertions" ; # spin:violationSource
    spin:body [
        rdf:type sp:Construct ;
        sp:text """
            PREFIX owl2spin: <http://constraints.org/owl2#>
        	CONSTRUCT {            
                ?this 
            	    a spin:ConstraintViolation ;
                    spin:violationRoot ?this ;
                    rdfs:label ?violationMessage ;
                    spin:violationPath ?DPE .
        	}
        	WHERE {
#               NegativeDataPropertyAssertion ( axiomAnnotations DataPropertyExpression sourceIndividual targetValue )
#				-----
			    ?negativeDataPropertyAssertion 
			        a owl:NegativePropertyAssertion ;
			        owl:sourceIndividual ?sourceIndividual ;
			        owl:assertionProperty ?OPE ;
			        owl:targetValue ?targetValue .
				        
#				DataPropertyAssertion( DataPropertyExpression sourceIndividual targetValue ) 
#               ----
                ?sourceIndividual ?DPE ?targetValue . 
                FILTER NOT EXISTS { ?targetValue rdf:type owl:Thing } # ?DPE is DPE
                
                FILTER ( ?this = ?sourceIndividual ) .
        		    
#               violation message
#               -----
                BIND ( CONCAT( 
                    \"NegativeDataPropertyAssertion ( \", 
                    xsd:string( ?DPE ), 
                    \" \", 
                    xsd:string( ?sourceIndividual ), 
                    \" \", 
                    xsd:string( ?targetValue ), 
                    \" ) | The individual '\", 
                    xsd:string( ?sourceIndividual ), 
                    \"' must not have to be connected by the data property expression '\", 
                    xsd:string( ?DPE ), 
                    \"' to the literal '\", 
                    xsd:string( ?targetValue ),
                    \"'.\" ) 
                    AS ?violationMessage ) . 
            }
            """ ;
    ] .
    
# ----

# ---------------
# Axioms - Datatype Definition


# Pattern
# -----
owl2spin:DatatypeDefinition_Pattern
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "Axioms - Datatype Definition" ;
	rdfs:label "Axioms - Datatype Definition" ;
	rdfs:comment "Axioms - Datatype Definition" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?label
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?DPE ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "label" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "DPE" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object "" ] ) ;
		sp:where ( 
#		WHERE {
#           ?this ?DPE ?L .
#           BIND ( ( str ( ?L ) ) AS ?L_str ) . 
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "DPE" ] ;
				sp:object [ sp:varName "L" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "L_str" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "L" ] ] ] 
				
#		    ?DT rdf:type rdfs:Datatype .
#           BIND ( ( datatype ( ?L ) ) AS ?datatype ) . 
#           FILTER ( DT = datatype ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "L" ] ] ] 
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "DT" ] ;
					sp:arg2 [ sp:varName "datatype" ] ] ]
					
#           ?DT owl:equivalentClass ?EC .
#           ?EC rdf:type rdfs:Datatype .
#           ?EC owl:onDatatype xsd:string .
#           ?EC owl:withRestrictions ?list .
#           ?list rdf:first ?e1 .
#           ?e1 xsd:pattern ?pattern .
#           ?list rdf:rest ?R1 .
#           FILTER ( ?R1 = rdf:nil ) .
#           -----
			[   sp:subject [ sp:varName "DT" ] ;
			    sp:predicate owl:equivalentClass ;
				sp:object [ sp:varName "EC" ] ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate rdf:type ;
				sp:object rdfs:Datatype ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:onDatatype ;
				sp:object xsd:string ]
			[   sp:subject [ sp:varName "EC" ] ;
			    sp:predicate owl:withRestrictions ;
				sp:object [ sp:varName "list" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:first ;
				sp:object [ sp:varName "e1" ] ]
			[   sp:subject [ sp:varName "e1" ] ;
			    sp:predicate xsd:pattern ;
				sp:object [ sp:varName "pattern" ] ]
			[   sp:subject [ sp:varName "list" ] ;
			    sp:predicate rdf:rest ;
				sp:object [ sp:varName "R1" ] ]	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "R1" ];
					sp:arg2 rdf:nil ] ]
	
#           FILTER( fn:matches ( ?L_str, ?pattern ) = "false"^^xsd:boolean ) . 	
			[   a sp:Filter;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [
							a fn:matches; 
							sp:arg1 [ sp:varName "L_str" ] ;
							sp:arg2 [ sp:varName "pattern" ] ] ;
					sp:arg2 "false"^^xsd:boolean ] ]

#           testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "label" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "L: " ;
#					sp:arg2 [ sp:varName "L" ] ;
#					sp:arg3 " | datatype (L): " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " | DT: " ;
#					sp:arg6 [ sp:varName "DT" ] ;
#					sp:arg7 " | pattern: " ;
#					sp:arg8 [ sp:varName "pattern" ] ;
#					sp:arg9 " | matches: " ;
#					sp:arg10 [ sp:varName "matches" ] ;
#					sp:arg11 "" ] ] ) ].	

#    		BIND ( ... ) AS ?label ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "label" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "String '" ;
					sp:arg2 [ sp:varName "L_str" ] ;
					sp:arg3 "' does not match the pattern '" ;
					sp:arg4 [ sp:varName "pattern" ] ;
					sp:arg5 "'" ] ] ) ] .
					
# -----

# ---------------
# cardinality functions


owl2spin:cardinalityDPE
    rdf:type spin:Function ;
    rdfs:subClassOf spin:Functions ;
    rdfs:label "cardinality DPE" ;
    rdfs:comment "cardinality DPE" ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg1 ;
        spl:valueType rdf:subject ;
        rdfs:comment "subject" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg2 ;
        spl:valueType rdf:Property ;
        rdfs:comment "DPE" ; 
    ] ;
    spin:body [
        rdf:type sp:Select ;
        sp:text """
            SELECT ( COUNT ( ?arg1 ) AS ?cardinality)
            WHERE {
                ?arg1 ?arg2 ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
            }
        """ ;
    ] ;
    spin:returnType xsd:nonNegativeInteger .
    
owl2spin:qualifiedCardinalityDPE
    rdf:type spin:Function ;
    rdfs:subClassOf spin:Functions ;
    rdfs:label "qualified cardinality DPE" ;
    rdfs:comment "qualified cardinality DPE" ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg1 ;
        spl:valueType rdf:subject ;
        rdfs:comment "subject" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg2 ;
        spl:valueType rdf:Property ;
        rdfs:comment "DPE" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg3 ;
        spl:valueType rdfs:Datatype ;
        rdfs:comment "DR" ; 
    ] ;
    spin:body [
        rdf:type sp:Select ;
        sp:text """
            SELECT ( COUNT ( ?arg1 ) AS ?cardinality)
            WHERE {
                ?arg1 ?arg2 ?l .
                FILTER NOT EXISTS { ?l rdf:type owl:Thing } # ?DPE is DPE
                
                BIND ( DATATYPE( ?l ) AS ?datatype ) .
				FILTER ( ?datatype = ?arg3 ) .
            }
        """ ;
    ] ;
    spin:returnType xsd:nonNegativeInteger .
    
owl2spin:cardinalityOPE
    rdf:type spin:Function ;
    rdfs:subClassOf spin:Functions ;
    rdfs:label "cardinality OPE" ;
    rdfs:comment "cardinality OPE" ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg1 ;
        spl:valueType rdf:subject ;
        rdfs:comment "subject" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg2 ;
        spl:valueType rdf:Property ;
        rdfs:comment "OPE" ; 
    ] ;
    spin:body [
        rdf:type sp:Select ;
        sp:text """
            SELECT ( COUNT ( ?arg1 ) AS ?cardinality)
            WHERE {
                ?arg1 ?arg2 ?o .
                ?o rdf:type owl:Thing # ?OPE is OPE
            }
        """ ;
    ] ;
    spin:returnType xsd:nonNegativeInteger .
    
owl2spin:qualifiedCardinalityOPE
    rdf:type spin:Function ;
    rdfs:subClassOf spin:Functions ;
    rdfs:label "qualified cardinality OPE" ;
    rdfs:comment "qualified cardinality OPE" ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg1 ;
        spl:valueType rdf:subject ;
        rdfs:comment "subject" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg2 ;
        spl:valueType rdf:Property ;
        rdfs:comment "OPE" ; 
    ] ;
    spin:constraint [
        rdf:type spl:Argument ;
        spl:predicate sp:arg3 ;
        spl:valueType rdfs:Class ;
        rdfs:comment "CE" ; 
    ] ;
    spin:body [
        rdf:type sp:Select ;
        sp:text """
            SELECT ( COUNT ( ?arg1 ) AS ?cardinality)
            WHERE {
                ?arg1 ?arg2 ?o .
                ?o rdf:type owl:Thing . # ?OPE is OPE
                ?o rdf:type ?arg3 .
            }
        """ ;
    ] ;
    spin:returnType xsd:nonNegativeInteger .

# -----